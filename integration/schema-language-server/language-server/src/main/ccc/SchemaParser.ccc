PARSER_CLASS=SchemaParser;
PARSER_PACKAGE=ai.vespa.schemals.parser;
FAULT_TOLERANT=true;

INJECT SchemaParser:

    import java.io.OutputStream;
    import java.util.List;

    import com.yahoo.schema.DistributableResource;
    import com.yahoo.schema.FeatureNames;
    import com.yahoo.schema.OnnxModel;
    import com.yahoo.schema.RankProfile.DiversitySettings;
    import com.yahoo.schema.RankProfile.MatchSettings;
    import com.yahoo.schema.RankProfile;
    import com.yahoo.schema.Schema;

    import com.yahoo.schema.parser.DictionaryOption;
    import com.yahoo.schema.parser.ParsedAnnotation;
    import com.yahoo.schema.parser.ParsedAttribute;
    import com.yahoo.schema.parser.ParsedDocument;
    import com.yahoo.schema.parser.ParsedDocumentSummary;
    import com.yahoo.schema.parser.ParsedField;
    import com.yahoo.schema.parser.ParsedFieldSet;
    import com.yahoo.schema.parser.ParsedIndex;
    import com.yahoo.schema.parser.ParsedIndexingOp;
    import com.yahoo.schema.parser.ParsedMatchSettings;
    import com.yahoo.schema.parser.ParsedRankFunction;
    import com.yahoo.schema.parser.ParsedRankProfile;
    import com.yahoo.schema.parser.ParsedSchema;
    import com.yahoo.schema.parser.ParsedSorting;
    import com.yahoo.schema.parser.ParsedStruct;
    import com.yahoo.schema.parser.ParsedSummaryField;
    import com.yahoo.schema.parser.ParsedType;

    import com.yahoo.schema.document.Case;
    import com.yahoo.schema.document.HnswIndexParams;
    import com.yahoo.schema.document.MatchType;
    import com.yahoo.schema.document.MatchAlgorithm;
    import com.yahoo.schema.document.Sorting;
    import com.yahoo.schema.document.Stemming;

    import com.yahoo.searchlib.rankingexpression.FeatureList;
    import com.yahoo.searchlib.rankingexpression.Reference;

    import com.yahoo.tensor.TensorType;
{

    private PrintStream logger = new PrintStream(
        new OutputStream() {
            public void write(int b) {
                return;
            }
        }
    );

    public SchemaParser(PrintStream logger, String inputSource, CharSequence content) {
        this(inputSource, content);
        this.logger = logger;
    }

    /**
     * Parses the given token image as a ranking expression feature list.
     *
     * @param image The token image to parse.
     * @return The consumed feature list.
     * @throws ParseException Thrown if the image could not be parsed.
     */
    private FeatureList getFeatureList(String image, List<NonTerminalCall> callStack) throws ParseException {
        logger.println(image);
        try {
            return new FeatureList(image);
        }
        catch (com.yahoo.searchlib.rankingexpression.parser.ParseException e) {
            throw (ParseException) new ParseException(
                "Could not parse feature list '" + lastConsumedToken.toString() + "' at " +
                lastConsumedToken.getLocation(),
                lastConsumedToken,
                callStack
            ).initCause(e);
        }
    }
    
}

// --------------------------------------------------------------------------------
//
// Token declarations.
//
// --------------------------------------------------------------------------------

// Declare white space characters. These do not include newline because it has
// special meaning in several of the production rules.
SKIP :
  " " | "\t" | "\r" | "\f"
;


// Declare all tokens to be recognized. When a word token is added it MUST be
// added to the identifier() production rule.
TOKEN :
  < NL: "\n" >
| < ANNOTATION: "annotation" >
| < ANNOTATIONREFERENCE: "annotationreference" >
| < SCHEMA: "schema" >
| < SEARCH: "search" >
| < DIVERSITY: "diversity" >
| < MIN_GROUPS: "min-groups" >
| < CUTOFF_FACTOR: "cutoff-factor" >
| < CUTOFF_STRATEGY: "cutoff-strategy" >
| < LOOSE: "loose" >
| < STRICT: "strict" >
| < DOCUMENT: "document" >
| < OPERATION: "operation" >
| < ON_MATCH: "on-match" >
| < ON_FIRST_PHASE: "on-first-phase" >
| < ON_SECOND_PHASE: "on-second-phase" >
| < ON_SUMMARY: "on-summary" >
| < STRUCT: "struct" >
| < INHERITS: "inherits" >
| < FIELD: "field" >
| < FIELDS: "fields" >
| < FIELDSET: "fieldset" >
| < STRUCT_FIELD: "struct-field" >
| < IMPORT: "import" >
| < AS: "as" >
| < INDEXING: "indexing" >
| < SUMMARY_TO: "summary-to" >
| < DOCUMENT_SUMMARY: "document-summary" >
| < RANK_TYPE: "rank-type" >
| < WEIGHT: "weight" >
| < TYPE: "type" >
| < INDEX: "index" >
| < INPUTS: "inputs">
| < MTOKEN: "token" >
| < TEXT: "text" >
| < WORD: "word" >
| < GRAM: "gram" >
| < GRAM_SIZE: "gram-size" >
| < MAX_LENGTH: "max-length" >
| < MAX_OCCURRENCES: "max-occurrences" >
| < MAX_TOKEN_LENGTH: "max-token-length" >
| < PREFIX: "prefix" >
| < SUBSTRING: "substring" >
| < SUFFIX: "suffix" >
| < CONSTANT: "constant">
| < ONNX_MODEL: "onnx-model">
| < SIGNIFICANCE: "significance">
| < USE_MODEL: "use-model">
| < INTRAOP_THREADS: "intraop-threads">
| < INTEROP_THREADS: "interop-threads">
| < GPU_DEVICE: "gpu-device">
| < EXECUTION_MODE: "execution-mode">
| < PARALLEL: "parallel">
| < SEQUENTIAL: "sequential">
| < MODEL: "model" >
| < MUTATE: "mutate" >
| < QUERY: "query" >
| < RANK_PROFILE: "rank-profile" >
| < RAW_AS_BASE64_IN_SUMMARY: "raw-as-base64-in-summary" >
| < SUMMARY: "summary" >
| < FULL: "full" >
| < STATIC: "static" >
| < DYNAMIC: "dynamic" >
| < TOKENS: "tokens" >
| < MATCHED_ELEMENTS_ONLY: "matched-elements-only" >
| < SSCONTEXTUAL: "contextual" >
| < SSOVERRIDE: "override" >
| < SSTITLE: "title" >
| < SSURL: "url" >
| < PROPERTIES: "properties" >
| < ATTRIBUTE: "attribute" >
| < SORTING: "sorting" >
| < DICTIONARY: "dictionary" >
| < ASCENDING: "ascending" >
| < DESCENDING: "descending" >
| < UCA: "uca" >
| < RAW: "raw" >
| < LOWERCASE: "lowercase" >
| < FUNCTION: "function" >
| < LOCALE: "locale" >
| < STRENGTH: "strength" >
| < PRIMARY: "primary" >
| < SECONDARY: "secondary" >
| < TERTIARY: "tertiary" >
| < QUATERNARY: "quaternary" >
| < IDENTICAL: "identical" >
| < STEMMING: "stemming" >
| < NORMALIZING: "normalizing" >
| < HASH: "hash" >
| < BTREE: "btree" >
| < CASED: "cased" >
| < UNCASED: "uncased" >
| < BOLDING: "bolding" >
| < NONE: "none" >
| < ON: "on" >
| < OFF: "off" >
| < TRUE: "true" >
| < FALSE: "false" >
| < SYMMETRIC: "symmetric" >
| < QUERY_COMMAND: "query-command" >
| < ALIAS: "alias" >
| < MATCH: "match" >
| < RANK: "rank" >
| < LITERAL: "literal" >
| < EXACT: "exact" >
| < FILTER: "filter" >
| < NORMAL: "normal" >
| < EXACT_TERMINATOR: "exact-terminator" >
| < IGNORE_DEFAULT_RANK_FEATURES: "ignore-default-rank-features" >
| < ID: "id" >
| < SOURCE: "source" >
| < TO: "to" >
| < DIRECT: "direct" >
| < FROM_DISK: "from-disk" >
| < OMIT_SUMMARY_FEATURES: "omit-summary-features" >
| < ALWAYS: "always" >
| < ON_DEMAND: "on-demand" >
| < NEVER: "never" >
| < ENABLE_BIT_VECTORS: "enable-bit-vectors" >
| < ENABLE_ONLY_BIT_VECTOR: "enable-only-bit-vector" >
| < FAST_ACCESS: "fast-access" >
| < MUTABLE: "mutable" >
| < PAGED: "paged" >
| < FAST_RANK: "fast-rank" >
| < FAST_SEARCH: "fast-search" >
| < TENSOR_TYPE: "tensor" ("<" (~["<",">"])+ ">")? "(" (~["(",")"])* ")" >
| < TENSOR_VALUE_SL: "value" (" ")* ":" (" ")* ("{"<BRACE_SL_LEVEL_1>) ("\n")? >
| < TENSOR_VALUE_ML: "value" (<SEARCHLIB_SKIP>)? "{" (["\n"," "])* ("{"<BRACE_ML_LEVEL_1>) (["\n"," "])* "}" ("\n")? >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COLON: ":" >
| < DOT: "." >
| < COMMA: "," >
| < ARRAY: "array" >
| < WEIGHTEDSET: "weightedset" >
| < MAP: "map" >
| < REFERENCE: "reference" >
| < QUESTIONMARK: "?" >
| < CREATE_IF_NONEXISTENT: "create-if-nonexistent" >
| < REMOVE_IF_ZERO: "remove-if-zero" >
| < MATCH_PHASE: "match-phase" >
| < EVALUATION_POINT: "evaluation-point" >
| < PRE_POST_FILTER_TIPPING_POINT: "pre-post-filter-tipping-point" >
| < ORDER: "order" >
| < MAX_FILTER_COVERAGE: "max-filter-coverage" >
| < MAX_HITS: "max-hits" >
| < FIRST_PHASE: "first-phase" >
| < SECOND_PHASE: "second-phase" >
| < GLOBAL_PHASE: "global-phase" >
| < MACRO: "macro" >
| < INLINE: "inline" >
| < ARITY: "arity" >
| < LOWER_BOUND: "lower-bound" >
| < UPPER_BOUND: "upper-bound" >
| < DENSE_POSTING_LIST_THRESHOLD: "dense-posting-list-threshold" >
| < ENABLE_BM25: "enable-bm25" >
| < HNSW: "hnsw" >
| < MAX_LINKS_PER_NODE: "max-links-per-node" >
| < DOUBLE_KEYWORD: "double" >
| < FLOAT_KEYWORD: "float" >
| < LONG_KEYWORD: "long" >
| < STRING_KEYWORD: "string" >
| < DISTANCE_METRIC: "distance-metric" >
| < NEIGHBORS_TO_EXPLORE_AT_INSERT: "neighbors-to-explore-at-insert" >
| < MULTI_THREADED_INDEXING: "multi-threaded-indexing" >
| < MATCHFEATURES_SL: "match-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < MATCHFEATURES_ML: "match-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < MATCHFEATURES_ML_INHERITS: "match-features inherits " (<IDENTIFIER_WITH_DASH>) (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < SUMMARYFEATURES_SL: "summary-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < SUMMARYFEATURES_ML: "summary-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < SUMMARYFEATURES_ML_INHERITS: "summary-features inherits " (<IDENTIFIER_WITH_DASH>) (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < RANKFEATURES_SL: "rank-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < RANKFEATURES_ML: "rank-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < EXPRESSION_SL: "expression" (" ")* ":" (("{"<BRACE_SL_LEVEL_1>)|<BRACE_SL_CONTENT>)* ("\n")? >
| < EXPRESSION_ML: "expression" (<SEARCHLIB_SKIP>)? "{" (("{"<BRACE_ML_LEVEL_1>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_1: (("{"<BRACE_SL_LEVEL_2>)|<BRACE_SL_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_2: (("{"<BRACE_SL_LEVEL_3>)|<BRACE_SL_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_3: <BRACE_SL_CONTENT> "}" >
| < #BRACE_SL_CONTENT: (~["{","}","\n"])+ >
| < #BRACE_ML_LEVEL_1: (("{"<BRACE_ML_LEVEL_2>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_ML_LEVEL_2: (("{"<BRACE_ML_LEVEL_3>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_ML_LEVEL_3: <BRACE_ML_CONTENT> "}" >
| < #BRACE_ML_CONTENT: (~["{","}"])+ >
| < #SEARCHLIB_SKIP: ([" ","\f","\n","\r","\t"])+ >
| < RANK_PROPERTIES: "rank-properties" >
| < RERANK_COUNT: "rerank-count" >
| < NUM_THREADS_PER_SEARCH: "num-threads-per-search" >
| < MIN_HITS_PER_THREAD: "min-hits-per-thread" >
| < NUM_SEARCH_PARTITIONS: "num-search-partitions" >
| < TERMWISE_LIMIT: "termwise-limit" >
| < POST_FILTER_THRESHOLD: "post-filter-threshold" >
| < APPROXIMATE_THRESHOLD: "approximate-threshold" >
| < TARGET_HITS_MAX_ADJUSTMENT_FACTOR: "target-hits-max-adjustment-factor" >
| < KEEP_RANK_COUNT: "keep-rank-count" >
| < RANK_SCORE_DROP_LIMIT: "rank-score-drop-limit" >
| < CONSTANTS: "constants" >
| < FILE: "file" >
| < URI: "uri" >
| < IDENTIFIER:           ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
| < IDENTIFIER_WITH_DASH: ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_","-"])* >
| < DOUBLEQUOTEDSTRING: "\"" ( ~["\""] )* "\"" >
| < SINGLEQUOTEDSTRING: "'" ( ~["'"] )* "'" >
| < CONTEXT: ["a"-"z","A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])* >
| < DOUBLE: ("-")? (["0"-"9"])+ "." (["0"-"9"])+ >
| < INTEGER: ("-")? (["0"-"9"])+ >
| < LONG: ("-")? (["0"-"9"])+"L" >
| < STRING: (["a"-"z","A"-"Z","_","0"-"9","."])+ >
| < FILE_PATH: ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_","-", "/", "."])+ >
| < HTTP: ["h","H"] ["t","T"] ["t","T"] ["p","P"] (["s","S"])? >
| < URI_PATH: <HTTP> <COLON> ("//")? (["a"-"z","A"-"Z","0"-"9","_","-", "/", ".",":"])+ >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < VARIABLE: "$" <IDENTIFIER> >
| < ONNX_INPUT_SL: "input" (" ")* (<IDENTIFIER>|<DOUBLEQUOTEDSTRING>) (" ")* ":" (" ")* (~["\n"])* ("\n")? >
| < ONNX_OUTPUT_SL: "output" (" ")* (<IDENTIFIER>|<DOUBLEQUOTEDSTRING>) (" ")* ":" (" ")* (~["\n"])* ("\n")? >
;


// Declare a special skip token for comments.
UNPARSED :
  <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* >
;


// --------------------------------------------------------------------------------
//
// Production rules.
//
// --------------------------------------------------------------------------------

/**
 * The rule consumes any schema and returns the corresponding object. This is the only production that should
 * ever consume leading newlines.
 *
 * @return the schema object
 * TODO: implement rootDocument
 */
ParsedSchema Root :
{
    ParsedSchema schema;
}
    (<NL>)* (schema = rootSchema)
    { return schema; }
;



/**
 * This rule consumes a proper schema block. This and rootDocument() are the only rules that should ever consume
 * trailing newline tokens.
 *
 * @return the schema definition object.
 * TODO: implement inheritance
 */
ParsedSchema rootSchema :
{
    String name;
    ParsedSchema schema;
}
    ( ( <SCHEMA> | <SEARCH> ) name = identifierStr {
        schema = new ParsedSchema(name);
      }
      openLbrace (rootSchemaItem(schema) | <NL>)*
      <RBRACE> (<NL>)* <EOF> )
    { return schema; }
;

/**
 * Consumes an element of a schema block. This and rootSearch() are the only rules that should ever consume
 * trailing newline tokens.
 *
 * @param schema the schema object to modify.
 */
rootSchemaItem(ParsedSchema schema) : {}
    ( 
        documentElm(schema)
    //   | rawAsBase64(schema)
       | searchStemming(schema)
    //   | importField(schema)
       | rankingConstant(schema) // Deprecated: TODO: Vespa > 8: Emit warning
        | rankProfile(schema)
       | documentSummary(schema)
        | fieldOutsideDoc(schema)
       | indexOutsideDoc(schema)
        | structOutsideDoc(schema)
    //   | annotationOutside(schema)
        | fieldSetElm(schema)
       | onnxModelInSchema(schema) // Deprecated: TODO: Vespa > 8: Emit warning
 )
;

/**
 * Consumes a document element. The name defaults to the schema's name, but may be set.
 *
 * @param schema the schema object to add content to.
 */
void documentElm(ParsedSchema schema) :
{
    String name = schema.name();
    ParsedDocument document;
}

    ( <DOCUMENT> (name = identifierStr)? (<NL>)*
    {
        document = new ParsedDocument(name);
    }
      openLbrace (documentElmBody(document) | <NL>)* <RBRACE> )
    {
        schema.addDocument(document);
    }
;

/**
 * Consumes a document body block
 *
 * @param document the document type to modify.
 */
void documentElmBody(ParsedDocument document) : {}
    (
        structInsideDoc(document)
        | fieldInsideDoc(document)
    )
;

/**
 * Consumes a field block from within a document element.
 *
 * @param document the document type to modify
 */
void fieldInsideDoc(ParsedDocument document) :
{
    ParsedField field;
}
    field = fieldElm() {
        document.addField(field);
    }
;

/**
 * Consumes a field block from outside a document element.
 *
 * @param schema the schema to modify
 */
void fieldOutsideDoc(ParsedSchema schema) :
{
    ParsedField field;
}

    field = fieldElm() { schema.addField(field); }
;

/**
 * Consumes a field block
 */
ParsedField fieldElm() :
{
    String name;
    ParsedField field;
    ParsedType type;
}

    <FIELD> name = identifierStr <TYPE> type = dataType()
    {
        field = new ParsedField(name, type);
    }
    openLbrace() ( fieldBodyElm(field) | <NL>)* <RBRACE>
    {
        return field;
    }
;

/** Consumes a fieldset block */
void fieldSetElm(ParsedSchema schema) :
{
  String name;
  ParsedFieldSet fieldSet;
}

  <FIELDSET> name = identifierStr openLbrace() { fieldSet = new ParsedFieldSet(name); }
    ((fieldsElm(fieldSet) | queryCommandInFieldSetElm(fieldSet)) (<NL>)*)+
  <RBRACE>
  {
     schema.addFieldSet(fieldSet);
  }
;

void fieldsElm(ParsedFieldSet fieldSet) :
{
    String name;
}
    (
        <FIELDS><COLON> name = identifierStr { fieldSet.addField(name); }
        ( <COMMA> name = identifierStr { fieldSet.addField(name); })*
    )
;

void queryCommandInFieldSetElm(ParsedFieldSet fieldSet) :
{
    String queryCommand;
}
    (
        <QUERY_COMMAND><COLON> (queryCommand = identifierWithDashStr | queryCommand = quotedString) { fieldSet.addQueryCommand(queryCommand); }
    )
;

/**
 * This rule consumes a struct block from within a document element.
 * @param document the document object to add content to
 */
void structInsideDoc(ParsedDocument document) :
{
    ParsedStruct struct;
}

    struct = structDefinitionElm() { document.addStruct(struct); }
;

/**
 * This rule consumes a struct block from within a schema element.
 * @param schema the schema object to add content to
 */
void structOutsideDoc(ParsedSchema schema) :
{
    ParsedStruct struct;
}

    struct = structDefinitionElm() { schema.addStruct(struct); }
;

/**
 * This rule consumes a struct declaration block
 */
ParsedStruct structDefinitionElm() :
{
    String name;
//    String inherited;
    ParsedStruct struct;
}

    ( <STRUCT> name = identifierStr (<NL>)* { struct = new ParsedStruct(name); }
//    [ inheritsStruct(struct) (<NL>)* ]
    openLbrace() (structFieldDefinition(struct) | <NL>)* <RBRACE> )
    {
        return struct;
    }
;

/**
 * This rule consumes a data type block from within a field element.
 *
 * @return the consumed data type
 */
ParsedType dataType() :
{
    String typeName = null;
    boolean isArrayOldStyle = false;
    ParsedType mapType = null;
    ParsedType arrayType = null;
    ParsedType wsetType = null;
    TensorType tensorType;
    ParsedType referenceType;
}
    (     SCAN(<ARRAY> <LESSTHAN>)               => ( <ARRAY> <LESSTHAN> arrayType = dataType() <GREATERTHAN> { return ParsedType.arrayOf(arrayType); } )
        | SCAN(<WEIGHTEDSET> <LESSTHAN>)         => ( <WEIGHTEDSET> <LESSTHAN> wsetType = dataType() <GREATERTHAN> { return ParsedType.wsetOf(wsetType); } )
        | SCAN(<MAP> <LESSTHAN>)                 => ( mapType = mapDataType() { return mapType; } )
        | SCAN(<ANNOTATIONREFERENCE> <LESSTHAN>) => ( mapType = annotationRefDataType() { return mapType; } )
        | SCAN(<TENSOR_TYPE>)                    => ( tensorType = tensorTypeElm("Field type") { return ParsedType.tensorType(tensorType); } )
        | SCAN(<REFERENCE>)                      => ( <REFERENCE> <LESSTHAN> referenceType = referenceType() <GREATERTHAN> { return ParsedType.documentRef(referenceType); } )
        | ( typeName = identifierStr ["[]" { isArrayOldStyle = true; }] )
    )
    {
        ParsedType type = ParsedType.fromName(typeName);
        if (isArrayOldStyle) {
            //deployLogger.logApplicationPackage(Level.WARNING, "Data type syntax '" + typeName + "[]' is deprecated, use 'array<" + typeName + ">' instead.");
            type = ParsedType.arrayOf(type);
        }
        return type;
    }
;

ParsedType referenceType() :
{
    String documentName;
}

    ( documentName = identifierStr )
    {
        return ParsedType.documentType(documentName);
    }
;

ParsedType annotationRefDataType() :
{
    ParsedType dataType;
    String targetName;
}

    ( <ANNOTATIONREFERENCE> <LESSTHAN> targetName = identifierStr <GREATERTHAN> )
    {
        return ParsedType.annotationRef(targetName);
    }
;

ParsedType mapDataType() :
{
    ParsedType keyType;
    ParsedType valType;
}
  ( <MAP> <LESSTHAN> keyType = dataType() <COMMA> valType = dataType() <GREATERTHAN> )
  {
    return ParsedType.mapType(keyType, valType);
  }
;

/**
 * This rule consumes a field block of a struct body.
 *
 * @param struct The struct to modify.
 */
void structFieldDefinition(ParsedStruct struct) :
{
    String name;
    ParsedType type;
    ParsedField field;
    int fieldId;
}

    <FIELD> name = identifierStr <TYPE> type = dataType() {
        field = new ParsedField(name, type);
    }
    openLbrace (idElm(field) (<NL>)*)? (matchSettingsElm(field.matchSettings()) | <NL>)* <RBRACE>
    {
        struct.addField(field);
    }
;

/**
 * This rule consumes a struct subfield from a document field body. This is not to be confused with a document
 * struct's fields, but rather this is a subfield of a document field of type struct.
 *
 * @param field    the field to modify
 */
void structFieldElm(ParsedField field) :
{
    String name;
    ParsedField structField;
}
    <STRUCT_FIELD> name = identifierStr {
        if (name != null && Schema.isReservedName(name.toLowerCase())) {
            throw new IllegalArgumentException("Reserved name '" + name + "' can not be used as a field name.");
        }
        structField = new ParsedField(name, null);
    }
    openLbrace() (structFieldBodyElm(structField) | <NL>)* <RBRACE>
    { 
        field.addStructField(structField); 
    }
;

/**
 * This rule consumes a single element of a field body block.
 *
 * @param field    the field being built
 */
void fieldBodyElm(ParsedField field) : { }

     ( aliasElm(field) |
       attributeElm(field) |
       boldingElm(field) |
       dictionaryElm(field) |
       fieldStemming(field) |
       idElm(field) |
       summaryInField(field) |
       indexInsideField(field) |
    //   indexing(field) |
       matchSettingsElm(field.matchSettings()) |
       normalizingElm(field) |
       queryCommandInField(field) |
       rankElm(field) |
       rankTypeElm(field) |
       fieldSorting(field) |
       structFieldElm(field) |
       summaryToElm(field) |
       weightElm(field) |
       weightedsetElm(field.getType())
    )
;

/**
 * This rule consumes a single element of a struct subfield body block.
 * Only elements that are supported in streaming schema and indexed schema (with complex attributes) are allowed.
 *
 * @param field    the field being built
 */
void structFieldBodyElm(ParsedField field) : { }
    (  summaryInField(field) |
     // indexing(field) |
      attributeElm(field) |
      matchSettingsElm(field.matchSettings()) |
      queryCommandInField(field) |
      rankElm(field) |
      structFieldElm(field) |
      summaryToElm(field)
    )
;

/**
 * This rule consumes a summary-to statement of a field element.
 *
 * @param field The field to modify.
 */
void summaryToElm(ParsedField field) :
{
    String name = field.name();
    String destination;
    ParsedSummaryField psf;
}
    <SUMMARY_TO> [name = identifierStr()] <COLON> destination = identifierStr()
    {
        psf = field.summaryFieldFor(name);
        psf.addDestination(destination);
    }
    ( <COMMA> destination = identifierStr() { psf.addDestination(destination); } )*
;

/**
 * This rule consumes a weight statement of a field element.
 *
 * @param field The field to modify.
 */
void weightElm(ParsedField field) :
{
    int num;
}

    <WEIGHT> <COLON> num = integerElm { field.setWeight(num); }
;

/**
 * This rule consumes a weighted set statement of a field element.
 *
 * @param fieldType The field type to modify.
 */
void weightedsetElm(ParsedType fieldType) : { }
    <WEIGHTEDSET> ( (<COLON> weightedsetBody(fieldType))
                | (openLbrace() (weightedsetBody(fieldType) | <NL>)* <RBRACE>) )
;

/**
 * This rule consumes one body item of a weighted set block.
 *
 * @param type The field type to modify.
 */
void weightedsetBody(ParsedType type) : { }
    ( <CREATE_IF_NONEXISTENT> { type.setCreateIfNonExistent(true); }
      | <REMOVE_IF_ZERO>      { type.setRemoveIfZero(true); } )
;

/**
 * This rule consumes a rank-type statement of a field element.
 *
 * @param field The field to modify.
 */
void rankTypeElm(ParsedField field) :
{
    String typeName;
    String indexName = "";
}
    <RANK_TYPE> [indexName = identifierStr()] <COLON> typeName = identifierStr()
    {
        field.addRankType(indexName, typeName);
    }
;

/**
 * This rule consumes an attribute statement of a field element.
 *
 * @param field The field to modify.
 */
void attributeElm(ParsedField field) :
{
    String name = field.name();
}

    <ATTRIBUTE> [name = identifierStr]
    {
        // TODO: Remove support for attribute with different name than field name in Vespa 9
        // if ( ! name.equals(field.name()))
        //         deployLogger.logApplicationPackage(Level.WARNING, "Creating an attribute for field '" + field.name() +
        //         "' with a different name '" + name + "' than the field name" +
        //         " is deprecated, and support will be removed in Vespa 9. Define a field with the wanted name outside the document instead.");
        ParsedAttribute attr = field.attributeFor(name);
    }
         ( (<COLON> attributeSetting(attr))
           | (openLbrace() (attributeSetting(attr) | <NL>)* <RBRACE>) )
;

/* pick up sorting in field block */
void fieldSorting(ParsedField field) : { }

    sortingElm(field.sortInfo())
;


/* pick up sorting in attribute block */
void attributeSorting(ParsedAttribute attribute) : { }

    sortingElm(attribute.sortInfo())
;

/* pick up sorting in field block */
void sortingElm(ParsedSorting sort) : { }

    <SORTING>
          ( (<COLON> sortingSetting(sort))
            | (openLbrace() (sortingSetting(sort) | <NL>)* <RBRACE>) )
;



void sortingSetting(ParsedSorting sorting) :
{
    String locale;
}
 
    (
        <ASCENDING> { sorting.setAscending(); }
      | <DESCENDING> { sorting.setDescending(); }
      | <FUNCTION> <COLON> (
                               <UCA>       { sorting.setFunction(Sorting.Function.UCA); }
                             | <RAW>       { sorting.setFunction(Sorting.Function.RAW); }
                             | <LOWERCASE> { sorting.setFunction(Sorting.Function.LOWERCASE); }
                           )
      | <STRENGTH> <COLON> (
                               <PRIMARY>    { sorting.setStrength(Sorting.Strength.PRIMARY); }
                             | <SECONDARY>  { sorting.setStrength(Sorting.Strength.SECONDARY); }
                             | <TERTIARY>   { sorting.setStrength(Sorting.Strength.TERTIARY); }
                             | <QUATERNARY> { sorting.setStrength(Sorting.Strength.QUATERNARY); }
                             | <IDENTICAL>  { sorting.setStrength(Sorting.Strength.IDENTICAL); }
                           )
      | <LOCALE> <COLON> locale = identifierWithDashStr() { sorting.setLocale(locale); }
    )
;

/**
 * This rule consumes a single attribute setting statement of an attribute element.
 *
 * @param attribute The attribute to change.
 */
void attributeSetting(ParsedAttribute attribute) :
{
    String str;
}

    (
        <FAST_RANK>             { attribute.setFastRank(true); }
      | <FAST_SEARCH>           { attribute.setFastSearch(true); }
      | <FAST_ACCESS>           { attribute.setFastAccess(true); }
      | <MUTABLE>               { attribute.setMutable(true); }
      | <PAGED>                 { attribute.setPaged(true); }
      | <ENABLE_BIT_VECTORS>      //{ deployLogger.logApplicationPackage(Level.WARNING, "'enable-bit-vectors' is deprecated and void -> remove it. Will be removed in vespa-9"); }
      | <ENABLE_ONLY_BIT_VECTOR>  { attribute.setEnableOnlyBitVector(true); }
      | attributeSorting(attribute)
      | <ALIAS> {
            String alias;
            String aliasedName=attribute.name();
        } [aliasedName = identifierStr] <COLON> alias = identifierWithDashStr {
          attribute.addAlias(aliasedName, alias);
      }
      | <DISTANCE_METRIC> <COLON> str = identifierWithDashStr { attribute.setDistanceMetric(str); }
    )
;

/**
 * This rule consumes a summary statement defined inside a document-summary block.
 *
 * @param docsum The document summary to modify.
 */
void summaryInDocument(ParsedDocumentSummary docsum) :
{
    String name;
    ParsedType type = null;
    ParsedSummaryField psf;
}

    <SUMMARY> name = identifierWithDashStr() { }
    (<TYPE>   type = dataType())?
    openLbrace() {
        psf = new ParsedSummaryField(name, type);
	if (type != null) {
	    psf.setHasExplicitType();
	}
    }
    (summaryItem(psf) | <NL>)* <RBRACE>
    {
        var old = docsum.addField(psf);
        if (old != null) {
            // deployLogger.logApplicationPackage(Level.WARNING, "Summary field '" + psf.name()
            //                                   + "' is defined twice in document-summary '"
            //                                   + docsum.name() + "'");
        }
    }
;

/**
 * The rule consumes a summary statement defined inside a field.
 *
 * @param field The field to modify.
 */
void summaryInField(ParsedField field) : { }
 
    <SUMMARY> ( SCAN([identifierStr] <COLON>) => summaryInFieldShort(field)
              | summaryInFieldLong(field) )
;

/**
 * This rule consumes a single-line summary field.
 */
void summaryInFieldShort(ParsedField field) :
{
    String name = field.name();
    ParsedSummaryField psf;
}
 
    [ name = identifierStr() ]
    {
        psf = field.summaryFieldFor(name);
    }
    <COLON> ( <DYNAMIC> { psf.setDynamic(); }
              | <MATCHED_ELEMENTS_ONLY> { psf.setMatchedElementsOnly(); }
              | (<FULL> | <STATIC>) { psf.setFull(); }
              | <TOKENS> { psf.setTokens(); }
            )
;

/**
 * This rule consumes a multi-line summary field.
 */
void summaryInFieldLong(ParsedField field) :
{
    String name = field.name();
    ParsedType type = field.getType();
    boolean explicitType = false;
    ParsedSummaryField psf;
}
 
    ( [ name = identifierStr() [ <TYPE> { type = dataType(); explicitType = true; } ] ]
      openLbrace()
      {
          psf = field.summaryFieldFor(name, type);
	  if (explicitType) {
              psf.setHasExplicitType();
          }
      }
      (summaryItem(psf) | <NL>)* <RBRACE> )
;

/**
 * This rule consumes an item of a summary field block.
 *
 * @param field The field to modify.
 */
void summaryItem(ParsedSummaryField field) : { }
 
    ( summaryTransform(field)
      | summaryBolding(field)
      | summarySourceList(field)
      | summaryDestinationList(field)
    )
;

/**
 * This rule consumes a transform statement for a summary field element.
 *
 * @param field            The field to modify.
 */
void summaryTransform(ParsedSummaryField field) : { }
 
    ( <DYNAMIC>              { field.setDynamic(); }
     | <MATCHED_ELEMENTS_ONLY> { field.setMatchedElementsOnly(); }
     | (<FULL> | <STATIC>)   { field.setFull(); }
     | <TOKENS> { field.setTokens(); }
    )
;

/**
 * This rule consumes a bolding statement for a summary field element.
 *
 * @param field The summary field to modify.
 */
void summaryBolding(ParsedSummaryField field) :
{
    boolean bold;
}
 
    <BOLDING> <COLON> bold = bool()
    { field.setBold(bold); }
;

/**
 * This rule consumes a source-list statement for a summary field element.
 *
 * @param field The summary field to modify.
 */
void summarySourceList(ParsedSummaryField field) :
{
    String str;
}
 
    ( <SOURCE> <COLON> str = identifierStr() { field.addSource(str); }
      (        <COMMA> str = identifierStr() { field.addSource(str); } )* ) +
;

/**
 * This rule consumes a destination-list statement for a summary field element.
 *
 * @param field The summary field to modify.
 */
void summaryDestinationList(ParsedSummaryField field) :
{
    String str;
}
 
    <TO> <COLON> str = identifierStr() { field.addDestination(str); }
    (    <COMMA> str = identifierStr() { field.addDestination(str); } )*
;

/**
 * This rule consumes a stemming block of a field element.
 *
 * @param field The field to modify.
 */
void fieldStemming(ParsedField field) :
{
    String setting;
}
 
    <STEMMING> <COLON> setting = identifierWithDashStr
    {
        field.setStemming(Stemming.get(setting));
    }
;

/**
 * This rule consumes a stemming statement for a schema element.
 *
 * @param schema the schema to modify
 */
void searchStemming(ParsedSchema schema) :
{
    String setting;
}
 
    <STEMMING> <COLON> setting = identifierWithDashStr
    { schema.setStemming(Stemming.get(setting)); }
;

/**
 * This rule consumes a normalizing statement of a field element.
 * At the moment, this can only be used to turn off normalizing.
 *
 * @param field The field to modify.
 */
void normalizingElm(ParsedField field) :
{
    String setting;
}
 
    <NORMALIZING> <COLON> setting = identifierWithDashStr
    {
        field.setNormalizing(setting);
    }
;

/**
 * This rule consumes a bolding statement of a field element.
 *
 * @param field The field to modify.
 */
void boldingElm(ParsedField field) :
{
    boolean bold;
}
 
    <BOLDING> <COLON> bold = bool() { field.setBolding(bold); }
;

/**
 * This rule consumes a dictionary statement of a field element.
 *
 * @param field The field to modify.
 */
void dictionaryElm(ParsedField field) : { }
 
    <DICTIONARY>
    ( (<COLON> dictionarySetting(field))
    | (openLbrace() (dictionarySetting(field) | <NL>)* <RBRACE>))
;

void dictionarySetting(ParsedField field) : { }
 
    (   <HASH>            { field.dictionary(DictionaryOption.HASH); }
      | <BTREE>           { field.dictionary(DictionaryOption.BTREE); }
      | <CASED>           { field.dictionary(DictionaryOption.CASED); }
      | <UNCASED>         { field.dictionary(DictionaryOption.UNCASED); } )
    {}
;

void queryCommandInField(ParsedField field) :
{
    String command;
}
 
    <QUERY_COMMAND> <COLON> ( command = identifierWithDashStr() | command = quotedString() )
    {
        field.addQueryCommand(command);
    }
;

void aliasElm(ParsedField field) :
{
    String aliasedName = field.name();
    String alias;
}

    <ALIAS> [aliasedName = identifierStr] <COLON> alias = identifierWithDashStr
    {
       field.addAlias(aliasedName, alias);
    }
;

void matchSettingsElm(ParsedMatchSettings matchInfo) : { }

    <MATCH> ( (<COLON> matchType(matchInfo))
               | (openLbrace() (matchItem(matchInfo) | <NL>)* <RBRACE>) )
;

void matchType(ParsedMatchSettings matchInfo) : { }

    (   <MTOKEN>    { matchInfo.setType(MatchType.TEXT); } // Deprecated synonym to TEXT
      | <TEXT>      { matchInfo.setType(MatchType.TEXT); }
      | <WORD>      { matchInfo.setType(MatchType.WORD); }
      | <EXACT>     { matchInfo.setType(MatchType.EXACT); }
      | <GRAM>      { matchInfo.setType(MatchType.GRAM); }
      | <CASED>     { matchInfo.setCase(Case.CASED); }
      | <UNCASED>   { matchInfo.setCase(Case.UNCASED); }
      | <PREFIX>    { matchInfo.setAlgorithm(MatchAlgorithm.PREFIX); }
      | <SUBSTRING> { matchInfo.setAlgorithm(MatchAlgorithm.SUBSTRING); }
      | <SUFFIX>    { matchInfo.setAlgorithm(MatchAlgorithm.SUFFIX); } )
;

/**
 * This rule consumes a single match item for a match block.
 *
 * @param matchInfo The settings to modify.
 */
void matchItem(ParsedMatchSettings matchInfo) : { }
 
    ( matchType(matchInfo) | exactTerminator(matchInfo) | gramSize(matchInfo) | matchSize(matchInfo) |
     maxTermOccurrences(matchInfo) | maxTokenLength(matchInfo) )
;

void exactTerminator(ParsedMatchSettings matchInfo) :
{
    String terminator;
}
 
    <EXACT_TERMINATOR> <COLON> terminator = quotedString()
    {
        matchInfo.setExactTerminator(terminator);
    }
;

void gramSize(ParsedMatchSettings matchInfo) :
{
    int gramSize;
}
 
    <GRAM_SIZE> <COLON> gramSize = integerElm()
    {
        matchInfo.setGramSize(gramSize);
    }
;

void matchSize(ParsedMatchSettings matchInfo) :
{
    int matchSize;
}
 
    <MAX_LENGTH> <COLON> matchSize = integerElm() {
        matchInfo.setMaxLength(matchSize);
    }
;

void maxTermOccurrences(ParsedMatchSettings matchInfo) :
{
    int maxTermOccurrences;
}
 
    <MAX_OCCURRENCES> <COLON> maxTermOccurrences = integerElm() {
        matchInfo.setMaxTermOccurrences(maxTermOccurrences);
    }
;

void maxTokenLength(ParsedMatchSettings matchInfo) :
{
    int maxTokenLength;
}
 
    <MAX_TOKEN_LENGTH> <COLON> maxTokenLength = integerElm() {
        matchInfo.setMaxTokenLength(maxTokenLength);
    }
;

/**
 * Consumes a rank statement of a field element.
 *
 * @param field The field to modify.
 */
void rankElm(ParsedField field) : { }

    <RANK> ( (<COLON> rankSettingElm(field))
             | (openLbrace() (rankSettingElm(field) | <NL>)* <RBRACE>) )
;

/**
 * Consumes a single rank setting of a rank statement.
 *
 * @param field The field to modify.
 */
void rankSettingElm(ParsedField field) : { }

    ( <LITERAL>   { field.setLiteral(true); }
      | <NORMAL>  { field.setNormal(true); }
      | <FILTER>  { field.setFilter(true); } )
;


/**
 * Consumes an id statement of a field body block.
 *
 * @param field    The field to modify.
 */
void idElm(ParsedField field) :
{
    int fieldId;
}

    <ID> <COLON> fieldId = integerElm
    {
        field.setId(fieldId);
    }
;

/**
 * Consumes a document-summary block from within a schema block.
 *
 * @param schema the schema object to add content to
 */
void documentSummary(ParsedSchema schema) :
{
    String name;
    ParsedDocumentSummary summary;
}
 
    ( <DOCUMENT_SUMMARY>
      name = identifierWithDashStr() { summary = new ParsedDocumentSummary(name); }
      [inheritsDocumentSummary(summary)]
      openLbrace()
         (
           <FROM_DISK> { summary.setFromDisk(true); } |
           <OMIT_SUMMARY_FEATURES> { summary.setOmitSummaryFeatures(true); } |
           documentSummaryItem(summary) |
           <NL>
         )*
      <RBRACE>
    )
    { schema.addDocumentSummary(summary); }
;

/**
 * This rule consumes an inherits statement of a document summary.
 *
 * @param documentSummary the document summary to modify
 */
void inheritsDocumentSummary(ParsedDocumentSummary documentSummary) :
{
    String name;
}
 
    <INHERITS> name = identifierWithDashStr() { documentSummary.inherit(name); }
    ( <COMMA>  name = identifierWithDashStr() { documentSummary.inherit(name); } )*
;

/**
 * Consumes a single document-summary item.
 *
 * @param summary The document summary to modify.
 */
void documentSummaryItem(ParsedDocumentSummary summary) : { }
 
    summaryInDocument(summary)
;

/**
 * Consumes an index block in a schema element.
 *
 * @param schema the schema object to add content to
 */
void indexOutsideDoc(ParsedSchema schema) :
{
    ParsedIndex op;
    String indexName;
}
 
    <INDEX> indexName = identifierStr()
    {
        op = new ParsedIndex(indexName);
    }
    ( (<COLON> indexBody(op) (<COMMA> indexBody(op))*) |
      (openLbrace() (indexBody(op) | <NL>)* <RBRACE>) )
    {
        schema.addIndex(op);
    }
;

/**
 * Consumes an index block for a field element.
 *
 * @param field  the field to modify
 */
void indexInsideField(ParsedField field) :
{
    ParsedIndex op;
    String indexName = field.name();
}
 
    <INDEX> [indexName = identifierStr()]
    {
        // TODO: Remove support for index with different name than field name in Vespa 9
        //if ( ! indexName.equals(field.name()))
        //    deployLogger.logApplicationPackage(Level.WARNING, "Creating an index for field '" + field.name() +
        //    "' with a different name '" + indexName + "' than the field name" +
        //    " is deprecated, and support will be removed in Vespa 9. Define a field with the wanted name outside the document instead.");
        op = new ParsedIndex(indexName);
    }
    ( (<COLON> indexBody(op) (<COMMA> indexBody(op))*) |
      (openLbrace() (indexBody(op) | <NL>)* <RBRACE>) )
    {
        field.addIndex(op);
    }
;


/**
 * Consumes a single index statement for an index block.
 *
 * @param index The index to modify.
 */
void indexBody(ParsedIndex index) :
{
    String str;
    int arity;
    long num;
    double threshold;
}
 
    ( <PREFIX>                                                       { index.setPrefix(true); }
      | <ALIAS> <COLON> str = identifierWithDashStr()                   { index.addAlias(str); }
      | <STEMMING> <COLON> str = identifierWithDashStr()                { index.setStemming(Stemming.get(str)); }
      | <ARITY> <COLON> arity = integerElm()                            { index.setArity(arity); }
      | <LOWER_BOUND> <COLON> num = longValue()                       { index.setLowerBound(num); }
      | <UPPER_BOUND> <COLON> num = longValue()                       { index.setUpperBound(num); }
      | <DENSE_POSTING_LIST_THRESHOLD> <COLON> threshold = floatValue() { index.setDensePostingListThreshold(threshold); }
      | <ENABLE_BM25>                                                { index.setEnableBm25(true); }
      | hnswIndex(index)                                             { }
    )
;

void hnswIndex(ParsedIndex index) :
{
    HnswIndexParams.Builder params = new HnswIndexParams.Builder();
}
 
    ( SCAN(<HNSW> openLbrace()) =>
      (<HNSW> ( (openLbrace() (hnswIndexBody(params) | <NL>)* <RBRACE>) )) |
      <HNSW> )
    {
        index.setHnswIndexParams(params.build());
    }
;


void hnswIndexBody(HnswIndexParams.Builder params) :
{
    int num;
    boolean bool;
}
 
    ( <MAX_LINKS_PER_NODE> <COLON> num = integerElm() { params.setMaxLinksPerNode(num); }
      | <NEIGHBORS_TO_EXPLORE_AT_INSERT> <COLON> num = integerElm() { params.setNeighborsToExploreAtInsert(num); }
      | <MULTI_THREADED_INDEXING> <COLON> bool = bool() { params.setMultiThreadedIndexing(bool); } )
;

void onnxModelInSchema(ParsedSchema schema) :
{
    OnnxModel onnxModel;
}
 
    onnxModel = onnxModel() { schema.add(onnxModel); }
;

void onnxModelInProfile(ParsedRankProfile profile) :
{
    OnnxModel onnxModel;
}
 
    onnxModel = onnxModel() { profile.add(onnxModel); }
;

/** Consumes an onnx-model block. */
OnnxModel onnxModel() :
{
    String name;
    OnnxModel onnxModel;
}
 
    ( <ONNX_MODEL> name = identifierStr() { onnxModel = new OnnxModel(name); }
      openLbrace() (onnxModelItem(onnxModel) | <NL>)+ <RBRACE> )
    { return onnxModel; }
;

/**
 * Consumes an onnx-model block.
 *
 * @param onnxModel the onnxModel to modify
 */
void onnxModelItem(OnnxModel onnxModel) :
{
    String path = null;
    int num;
}
 
    (
        (path = fileItem()) { onnxModel.setFileName(path); } |
        (path = uriItem()) { onnxModel.setUri(path); } |
        <GPU_DEVICE> <COLON> num = integerElm() { onnxModel.setGpuDevice(num, false); } |
        <INTRAOP_THREADS> <COLON> num = integerElm() { onnxModel.setStatelessIntraOpThreads(num); } |
        <INTEROP_THREADS> <COLON> num = integerElm() { onnxModel.setStatelessInterOpThreads(num); } |
        <EXECUTION_MODE> <COLON> ( <PARALLEL> { onnxModel.setStatelessExecutionMode("parallel"); }
                                  | <SEQUENTIAL> { onnxModel.setStatelessExecutionMode("sequential"); } ) |
        (<ONNX_INPUT_SL>) {
            String name = lastConsumedToken.toString().substring(5, lastConsumedToken.toString().lastIndexOf(":")).trim();
            if (name.startsWith("\"")) { name = name.substring(1, name.length() - 1); }
            String source = lastConsumedToken.toString().substring(lastConsumedToken.toString().lastIndexOf(":") + 1).trim();
            onnxModel.addInputNameMapping(name, source);
        } |
        (<ONNX_OUTPUT_SL>) {
            String name = lastConsumedToken.toString().substring(6, lastConsumedToken.toString().lastIndexOf(":")).trim();
            if (name.startsWith("\"")) { name = name.substring(1, name.length() - 1); }
            String as = lastConsumedToken.toString().substring(lastConsumedToken.toString().lastIndexOf(":") + 1).trim();
            onnxModel.addOutputNameMapping(name, as);
        }
    )
;

/**
 * Consumes a constant block of a schema element.
 *
 * @param schema the schema object to add content to
 */
void rankingConstant(ParsedSchema schema) :
{
    String name;
    String path = null;
    DistributableResource.PathType pathType = DistributableResource.PathType.FILE;
    TensorType type = null;
}
 
    ( <CONSTANT> name = identifierStr() openLbrace()
      (path = fileItem() { pathType = DistributableResource.PathType.FILE; }
       | path = uriItem() { pathType = DistributableResource.PathType.URI; } // Undocumented. Remove?
       | type = tensorTypeWithPrefix(rankingConstantErrorMessage(name)) (<NL>)*
      )+
      <RBRACE>
    )
    {
        if (type == null) throw new IllegalArgumentException("constant '" + name + "' must have a type");
        if (path == null) throw new IllegalArgumentException("constant '" + name + "' must have a file");
        schema.add(new RankProfile.Constant(FeatureNames.asConstantFeature(name), type, path, pathType));
    }
;

String fileItem() :
{
   String path;
}
 
  (<FILE> <COLON> ( <FILE_PATH> | <STRING> | <IDENTIFIER>) { path = com.yahoo.path.Path.fromString(lastConsumedToken.toString()).getRelative(); } { } (<NL>)*) { return path; }
;

String uriItem() :
{
   String path;
}
 
  (<URI> <COLON> ( <URI_PATH> ) { path = lastConsumedToken.toString(); } (<NL>)*) { return path; }
;

String rankingConstantErrorMessage(String name) : {}
 
    { return "For ranking constant ' " + name + "'"; }
;


/**
 * Consumes a rank-profile block of a schema element.
 *
 * @param schema the schema object to add content to
 */
void rankProfile(ParsedSchema schema) :
{
    String name;
    ParsedRankProfile profile;
}

    ( <MODEL> | <RANK_PROFILE> ) name = identifierWithDashStr
    { profile = new ParsedRankProfile(name); }
    [inheritsRankProfile(profile)]
    openLbrace() (rankProfileItem(schema, profile) | <NL>)* <RBRACE>
    {
        schema.addRankProfile(profile);
    }
;

/**
 * This rule consumes a single statement for a rank-profile block.
 *
 * @param profile The rank profile to modify.
 */
void rankProfileItem(ParsedSchema schema, ParsedRankProfile profile) : { }

    (
        firstPhase(profile)
    //   fieldRankType(profile)
    //   | fieldWeight(profile)
    //   | fieldRankFilter(profile)
    //   | firstPhase(profile)
    //   | matchPhase(profile)
    //   | diversity(profile)
    //   | function(profile)
    //   | mutate(profile)
    //   | ignoreRankFeatures(profile)
    //   | numThreadsPerSearch(profile)
    //   | minHitsPerThread(profile)
    //   | numSearchPartitions(profile)
    //   | termwiseLimit(profile)
    //   | postFilterThreshold(profile)
    //   | approximateThreshold(profile)
    //   | targetHitsMaxAdjustmentFactor(profile)
      | rankFeaturesElm(profile)
    //   | rankProperties(profile)
    //   | secondPhase(profile)
    //   | globalPhase(profile)
    //   | inputs(profile)
    //   | constants(schema, profile)
      | matchFeaturesElm(profile)
    //   | summaryFeatures(profile)
       | onnxModelInProfile(profile)
    //   | strict(profile)
    //   | significance(profile)
    )
;

/**
 * Consumes an inherits statement of a rank-profile.
 *
 * @param profile the profile to modify
 */
void inheritsRankProfile(ParsedRankProfile profile) :
{
    String name;
}

    <INHERITS> name = identifierWithDashStr { profile.inherit(name); }
    ( <COMMA>  name = identifierWithDashStr { profile.inherit(name); } )*
;

/**
 * Consumes the first-phase block of a rank profile.
 *
 * @param profile The rank profile to modify.
 */
void firstPhase(ParsedRankProfile profile) :
{
    String exp;
}

    <FIRST_PHASE> openLbrace() (firstPhaseItem(profile) | <NL>)* <RBRACE>
;

void firstPhaseItem(ParsedRankProfile profile) :
{
    String expression;
    int keepRankCount;
    double dropLimit;
}

    ( expression = expression()                               { profile.setFirstPhaseRanking(expression); }
    | (<KEEP_RANK_COUNT> <COLON> keepRankCount = integerElm())     { profile.setKeepRankCount(keepRankCount); }
    | (<RANK_SCORE_DROP_LIMIT> <COLON> dropLimit = floatValue()) { profile.setRankScoreDropLimit(dropLimit); }
    )
;

TensorType tensorTypeWithPrefix(String errorMessage) :
{ TensorType type; }
 
    <TYPE> <COLON> type = tensorTypeElm(errorMessage)
    { return type; }
;


TensorType tensorTypeElm(String errorMessage) :
{
    String tensorTypeString;
}

    <TENSOR_TYPE> { tensorTypeString = lastConsumedToken.toString(); }
    {
        TensorType tensorType;
        try {
            tensorType = TensorType.fromSpec(tensorTypeString);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(errorMessage + ": Illegal tensor type spec: " + e.getMessage());
        }
        return tensorType;
    }
;

/**
 * Consumes a match-features block of a rank profile.
 *
 * @param profile the rank profile to modify
 */
void matchFeaturesElm(ParsedRankProfile profile) :
{
    String features;
}

    ( <MATCHFEATURES_SL> { features = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf(":") + 1).trim(); } |
      <MATCHFEATURES_ML> { features = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf("{") + 1,
                                                                             lastConsumedToken.toString().lastIndexOf("}")).trim(); } |
      <MATCHFEATURES_ML_INHERITS> {
          int inheritsIndex = lastConsumedToken.toString().indexOf("inherits ");
          String rest = lastConsumedToken.toString().substring(inheritsIndex + "inherits ".length());
          profile.setInheritedMatchFeatures(rest.substring(0, rest.indexOf(" ")).trim());
          features = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf("{") + 1, lastConsumedToken.toString().lastIndexOf("}")).trim();
      }
    )
    {
        profile.addMatchFeatures(getFeatureList(features, parsingStack));
    }
;

/** Consumes a rank-features block of a rank profile */
void rankFeaturesElm(ParsedRankProfile profile) :
{
    String features;
}

    ( <RANKFEATURES_SL> { features = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf(":") + 1).trim(); } 
      <RANKFEATURES_ML> { features = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf("{") + 1,
                                                                            lastConsumedToken.toString().lastIndexOf("}")).trim(); } )
    {
        profile.addRankFeatures(getFeatureList(features, parsingStack));
    }
;

/**
 * This rule consumes an expression token and returns its image.
 *
 * @return The consumed token image.
 */
String expression() :
{
    String exp;
}

    ( <EXPRESSION_SL> { exp = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf(":") + 1); } |
      <EXPRESSION_ML> { exp = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf("{") + 1,
                                                                     lastConsumedToken.toString().lastIndexOf("}")); } )
    { return exp.trim(); }
;

String identifierWithDashStr :
{
    String identifier;
}

    ( identifier = identifierStr { return identifier; } )
    |
    ( <IDENTIFIER_WITH_DASH>
    | <APPROXIMATE_THRESHOLD>
    | <CREATE_IF_NONEXISTENT>
    | <CUTOFF_FACTOR>
    | <CUTOFF_STRATEGY>
    | <DENSE_POSTING_LIST_THRESHOLD>
    | <DISTANCE_METRIC>
    | <DOCUMENT_SUMMARY>
    | <ENABLE_BIT_VECTORS>
    | <ENABLE_BM25>
    | <ENABLE_ONLY_BIT_VECTOR>
    | <EVALUATION_POINT>
    | <EXACT_TERMINATOR>
    | <EXECUTION_MODE>
    | <FAST_ACCESS>
    | <FAST_RANK>
    | <FAST_SEARCH>
    | <FIRST_PHASE>
    | <FROM_DISK>
    | <GLOBAL_PHASE>
    | <GPU_DEVICE>
    | <GRAM_SIZE>
    | <IGNORE_DEFAULT_RANK_FEATURES>
    | <INTEROP_THREADS>
    | <INTRAOP_THREADS>
    | <KEEP_RANK_COUNT>
    | <LOWER_BOUND>
    | <MATCHED_ELEMENTS_ONLY>
    | <MATCH_PHASE>
    | <MAX_FILTER_COVERAGE>
    | <MAX_HITS>
    | <MAX_LENGTH>
    | <MAX_LINKS_PER_NODE>
    | <MIN_GROUPS>
    | <MIN_HITS_PER_THREAD>
    | <MULTI_THREADED_INDEXING>
    | <NEIGHBORS_TO_EXPLORE_AT_INSERT>
    | <NUM_SEARCH_PARTITIONS>
    | <NUM_THREADS_PER_SEARCH>
    | <OMIT_SUMMARY_FEATURES>
    | <ON_DEMAND>
    | <ON_FIRST_PHASE>
    | <ON_MATCH>
    | <ONNX_MODEL>
    | <ON_SECOND_PHASE>
    | <ON_SUMMARY>
    | <POST_FILTER_THRESHOLD>
    | <PRE_POST_FILTER_TIPPING_POINT>
    | <QUERY_COMMAND>
    | <RANK_PROFILE>
    | <RANK_PROPERTIES>
    | <RANK_SCORE_DROP_LIMIT>
    | <RANK_TYPE>
    | <RAW_AS_BASE64_IN_SUMMARY>
    | <REMOVE_IF_ZERO>
    | <RERANK_COUNT>
    | <SECOND_PHASE>
    | <STRUCT_FIELD>
    | <SUMMARY_TO>
    | <TARGET_HITS_MAX_ADJUSTMENT_FACTOR>
    | <TERMWISE_LIMIT>
    | <UPPER_BOUND>
    | <USE_MODEL>
    ) {
        return lastConsumedToken.toString();
    }
;

/**
 * Consumes an identifier. This must be kept in sync with all word tokens that should be parseable as
 * identifiers.
 *
 * @return the identifier string
 */
String identifierStr :
    ( <ALIAS>
      | <ALWAYS>
      | <ANNOTATION>
      | <ANNOTATIONREFERENCE>
      | <ARITY>
      | <ARRAY>
      | <AS>
      | <ASCENDING>
      | <ATTRIBUTE>
      | <BOLDING>
      | <BTREE>
      | <CASED>
      | <CONSTANT>
      | <CONSTANTS>
      | <CONTEXT>
      | <DESCENDING>
      | <DICTIONARY>
      | <DIRECT>
      | <DIVERSITY>
      | <DOCUMENT>
      | <DOUBLE_KEYWORD>
      | <FLOAT_KEYWORD>
      | <LONG_KEYWORD>
      | <STRING_KEYWORD>
      | <DYNAMIC>
      | <EXACT>
      | <FALSE>
      | <FIELD>
      | <FIELDS>
      | <FIELDSET>
      | <FILE>
      | <FILTER>
      | <FULL>
      | <FUNCTION>
      | <GRAM>
      | <HASH>
      | <HNSW>
      | <ID>
      | <IDENTICAL>
      | <IDENTIFIER>
      | <IMPORT>
      | <INDEX>
      | <INDEXING>
      | <INHERITS>
      | <INLINE>
      | <INPUTS>
      | <INTEGER>
      | <LITERAL>
      | <LOCALE>
      | <LONG>
      | <LOOSE>
      | <LOWERCASE>
      | <MACRO>
      | <MAP>
      | <MATCH>
      | <MODEL>
      | <MTOKEN>
      | <MUTABLE>
      | <MUTATE>
      | <NEVER>
      | <NONE>
      | <NORMAL>
      | <NORMALIZING>
      | <OFF>
      | <ON>
      | <OPERATION>
      | <ORDER>
      | <PAGED>
      | <PARALLEL>
      | <PREFIX>
      | <PRIMARY>
      | <PROPERTIES>
      | <QUATERNARY>
      | <QUERY>
      | <RANK>
      | <RAW>
      | <REFERENCE>
      | <SCHEMA>
      | <SEARCH>
      | <SECONDARY>
      | <SEQUENTIAL>
      | <SORTING>
      | <SOURCE>
      | <SSCONTEXTUAL>
      | <SSOVERRIDE>
      | <SSTITLE>
      | <SSURL>
      | <STATIC>
      | <STEMMING>
      | <STRENGTH>
      | <STRICT>
      | <SIGNIFICANCE>
      | <STRING>
      | <STRUCT>
      | <SUBSTRING>
      | <SUFFIX>
      | <SUMMARY>
      | <SYMMETRIC>
      | <TERTIARY>
      | <TEXT>
      | <TO>
      | <TOKENS>
      | <TRUE>
      | <TYPE>
      | <UCA>
      | <UNCASED>
      | <URI>
      | <VARIABLE>
      | <WEIGHT>
      | <WEIGHTEDSET>
      | <WORD>
    ) {
        return lastConsumedToken.toString();
    }
;

/**
 * Consumes a quoted string token and returns the token image minus the quotes. This does not perform
 * unescaping of the content, it simply removes the first and last character of the image. However, the token itself can
 * contain anything but a double quote.
 *
 * @return the unquoted token image
 */
String quotedString() : { }

    ( <DOUBLEQUOTEDSTRING> | <SINGLEQUOTEDSTRING> )
    { return lastConsumedToken.toString().substring(1, lastConsumedToken.toString().length() - 1); }
;

/** A boolean value. */
Boolean bool() :

    ( ( <ON>  | <TRUE> )  { return true; } |
      ( <OFF> | <FALSE> ) { return false; } )
;

/** Consumes an integer token and returns its numeric value. */
int integerElm() : { }

    <INTEGER> { return Integer.parseInt(lastConsumedToken.toString()); }
;

/** Consumes a long or integer token and returns its numeric value. */
long longValue() : { }

    ( <INTEGER> { return Long.parseLong(lastConsumedToken.toString()); } |
      <LONG>    { return Long.parseLong(lastConsumedToken.toString().substring(0, lastConsumedToken.toString().length() - 1)); }
    )
;

/** Consumes a floating-point token and returns its numeric value. */
double floatValue() : { }

    <DOUBLE> { return Double.valueOf(lastConsumedToken.toString()); }
;

Number number() :
{
    Number num;
}

    ( num = floatValue | num = longValue ) { return num; }
;

void openLbrace() : { }
    ((<NL>)* <LBRACE> (<NL>)*)
;
