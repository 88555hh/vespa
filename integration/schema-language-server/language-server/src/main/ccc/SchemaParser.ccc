PARSER_CLASS=SchemaParser;
PARSER_PACKAGE=ai.vespa.schemals.parser;
LEGACY_GLITCHY_LOOKAHEAD=true;
FAULT_TOLERANT=true;

INJECT SchemaParser:
{

    import com.yahoo.schema.document.Case;
    import com.yahoo.schema.document.MatchType;
    import com.yahoo.schema.document.MatchAlgorithm;
    import com.yahoo.tensor.TensorType;
}

// --------------------------------------------------------------------------------
//
// Token declarations.
//
// --------------------------------------------------------------------------------

// Declare white space characters. These do not include newline because it has
// special meaning in several of the production rules.
SKIP :
  " " | "\t" | "\r" | "\f"
;


// Declare all tokens to be recognized. When a word token is added it MUST be
// added to the identifier() production rule.
TOKEN :
  < NL: "\n" >
| < ANNOTATION: "annotation" >
| < ANNOTATIONREFERENCE: "annotationreference" >
| < SCHEMA: "schema" >
| < SEARCH: "search" >
| < DIVERSITY: "diversity" >
| < MIN_GROUPS: "min-groups" >
| < CUTOFF_FACTOR: "cutoff-factor" >
| < CUTOFF_STRATEGY: "cutoff-strategy" >
| < LOOSE: "loose" >
| < STRICT: "strict" >
| < DOCUMENT: "document" >
| < OPERATION: "operation" >
| < ON_MATCH: "on-match" >
| < ON_FIRST_PHASE: "on-first-phase" >
| < ON_SECOND_PHASE: "on-second-phase" >
| < ON_SUMMARY: "on-summary" >
| < STRUCT: "struct" >
| < INHERITS: "inherits" >
| < FIELD: "field" >
| < FIELDS: "fields" >
| < FIELDSET: "fieldset" >
| < STRUCT_FIELD: "struct-field" >
| < IMPORT: "import" >
| < AS: "as" >
| < INDEXING: "indexing" >
| < SUMMARY_TO: "summary-to" >
| < DOCUMENT_SUMMARY: "document-summary" >
| < RANK_TYPE: "rank-type" >
| < WEIGHT: "weight" >
| < TYPE: "type" >
| < INDEX: "index" >
| < INPUTS: "inputs">
| < MTOKEN: "token" >
| < TEXT: "text" >
| < WORD: "word" >
| < GRAM: "gram" >
| < GRAM_SIZE: "gram-size" >
| < MAX_LENGTH: "max-length" >
| < MAX_OCCURRENCES: "max-occurrences" >
| < MAX_TOKEN_LENGTH: "max-token-length" >
| < PREFIX: "prefix" >
| < SUBSTRING: "substring" >
| < SUFFIX: "suffix" >
| < CONSTANT: "constant">
| < ONNX_MODEL: "onnx-model">
| < SIGNIFICANCE: "significance">
| < USE_MODEL: "use-model">
| < INTRAOP_THREADS: "intraop-threads">
| < INTEROP_THREADS: "interop-threads">
| < GPU_DEVICE: "gpu-device">
| < EXECUTION_MODE: "execution-mode">
| < PARALLEL: "parallel">
| < SEQUENTIAL: "sequential">
| < MODEL: "model" >
| < MUTATE: "mutate" >
| < QUERY: "query" >
| < RANK_PROFILE: "rank-profile" >
| < RAW_AS_BASE64_IN_SUMMARY: "raw-as-base64-in-summary" >
| < SUMMARY: "summary" >
| < FULL: "full" >
| < STATIC: "static" >
| < DYNAMIC: "dynamic" >
| < TOKENS: "tokens" >
| < MATCHED_ELEMENTS_ONLY: "matched-elements-only" >
| < SSCONTEXTUAL: "contextual" >
| < SSOVERRIDE: "override" >
| < SSTITLE: "title" >
| < SSURL: "url" >
| < PROPERTIES: "properties" >
| < ATTRIBUTE: "attribute" >
| < SORTING: "sorting" >
| < DICTIONARY: "dictionary" >
| < ASCENDING: "ascending" >
| < DESCENDING: "descending" >
| < UCA: "uca" >
| < RAW: "raw" >
| < LOWERCASE: "lowercase" >
| < FUNCTION: "function" >
| < LOCALE: "locale" >
| < STRENGTH: "strength" >
| < PRIMARY: "primary" >
| < SECONDARY: "secondary" >
| < TERTIARY: "tertiary" >
| < QUATERNARY: "quaternary" >
| < IDENTICAL: "identical" >
| < STEMMING: "stemming" >
| < NORMALIZING: "normalizing" >
| < HASH: "hash" >
| < BTREE: "btree" >
| < CASED: "cased" >
| < UNCASED: "uncased" >
| < BOLDING: "bolding" >
| < NONE: "none" >
| < ON: "on" >
| < OFF: "off" >
| < TRUE: "true" >
| < FALSE: "false" >
| < SYMMETRIC: "symmetric" >
| < QUERY_COMMAND: "query-command" >
| < ALIAS: "alias" >
| < MATCH: "match" >
| < RANK: "rank" >
| < LITERAL: "literal" >
| < EXACT: "exact" >
| < FILTER: "filter" >
| < NORMAL: "normal" >
| < EXACT_TERMINATOR: "exact-terminator" >
| < IGNORE_DEFAULT_RANK_FEATURES: "ignore-default-rank-features" >
| < ID: "id" >
| < SOURCE: "source" >
| < TO: "to" >
| < DIRECT: "direct" >
| < FROM_DISK: "from-disk" >
| < OMIT_SUMMARY_FEATURES: "omit-summary-features" >
| < ALWAYS: "always" >
| < ON_DEMAND: "on-demand" >
| < NEVER: "never" >
| < ENABLE_BIT_VECTORS: "enable-bit-vectors" >
| < ENABLE_ONLY_BIT_VECTOR: "enable-only-bit-vector" >
| < FAST_ACCESS: "fast-access" >
| < MUTABLE: "mutable" >
| < PAGED: "paged" >
| < FAST_RANK: "fast-rank" >
| < FAST_SEARCH: "fast-search" >
| < TENSOR_TYPE: "tensor" ("<" (~["<",">"])+ ">")? "(" (~["(",")"])* ")" >
| < TENSOR_VALUE_SL: "value" (" ")* ":" (" ")* ("{"<BRACE_SL_LEVEL_1>) ("\n")? >
| < TENSOR_VALUE_ML: "value" (<SEARCHLIB_SKIP>)? "{" (["\n"," "])* ("{"<BRACE_ML_LEVEL_1>) (["\n"," "])* "}" ("\n")? >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COLON: ":" >
| < DOT: "." >
| < COMMA: "," >
| < ARRAY: "array" >
| < WEIGHTEDSET: "weightedset" >
| < MAP: "map" >
| < REFERENCE: "reference" >
| < QUESTIONMARK: "?" >
| < CREATE_IF_NONEXISTENT: "create-if-nonexistent" >
| < REMOVE_IF_ZERO: "remove-if-zero" >
| < MATCH_PHASE: "match-phase" >
| < EVALUATION_POINT: "evaluation-point" >
| < PRE_POST_FILTER_TIPPING_POINT: "pre-post-filter-tipping-point" >
| < ORDER: "order" >
| < MAX_FILTER_COVERAGE: "max-filter-coverage" >
| < MAX_HITS: "max-hits" >
| < FIRST_PHASE: "first-phase" >
| < SECOND_PHASE: "second-phase" >
| < GLOBAL_PHASE: "global-phase" >
| < MACRO: "macro" >
| < INLINE: "inline" >
| < ARITY: "arity" >
| < LOWER_BOUND: "lower-bound" >
| < UPPER_BOUND: "upper-bound" >
| < DENSE_POSTING_LIST_THRESHOLD: "dense-posting-list-threshold" >
| < ENABLE_BM25: "enable-bm25" >
| < HNSW: "hnsw" >
| < MAX_LINKS_PER_NODE: "max-links-per-node" >
| < DOUBLE_KEYWORD: "double" >
| < FLOAT_KEYWORD: "float" >
| < LONG_KEYWORD: "long" >
| < STRING_KEYWORD: "string" >
| < DISTANCE_METRIC: "distance-metric" >
| < NEIGHBORS_TO_EXPLORE_AT_INSERT: "neighbors-to-explore-at-insert" >
| < MULTI_THREADED_INDEXING: "multi-threaded-indexing" >
| < MATCHFEATURES_SL: "match-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < MATCHFEATURES_ML: "match-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < MATCHFEATURES_ML_INHERITS: "match-features inherits " (<IDENTIFIER_WITH_DASH>) (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < SUMMARYFEATURES_SL: "summary-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < SUMMARYFEATURES_ML: "summary-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < SUMMARYFEATURES_ML_INHERITS: "summary-features inherits " (<IDENTIFIER_WITH_DASH>) (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < RANKFEATURES_SL: "rank-features" (" ")* ":" (~["}","\n"])* ("\n")? >
| < RANKFEATURES_ML: "rank-features" (<SEARCHLIB_SKIP>)? "{" (~["}"])* "}" >
| < EXPRESSION_SL: "expression" (" ")* ":" (("{"<BRACE_SL_LEVEL_1>)|<BRACE_SL_CONTENT>)* ("\n")? >
| < EXPRESSION_ML: "expression" (<SEARCHLIB_SKIP>)? "{" (("{"<BRACE_ML_LEVEL_1>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_1: (("{"<BRACE_SL_LEVEL_2>)|<BRACE_SL_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_2: (("{"<BRACE_SL_LEVEL_3>)|<BRACE_SL_CONTENT>)* "}" >
| < #BRACE_SL_LEVEL_3: <BRACE_SL_CONTENT> "}" >
| < #BRACE_SL_CONTENT: (~["{","}","\n"])+ >
| < #BRACE_ML_LEVEL_1: (("{"<BRACE_ML_LEVEL_2>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_ML_LEVEL_2: (("{"<BRACE_ML_LEVEL_3>)|<BRACE_ML_CONTENT>)* "}" >
| < #BRACE_ML_LEVEL_3: <BRACE_ML_CONTENT> "}" >
| < #BRACE_ML_CONTENT: (~["{","}"])+ >
| < #SEARCHLIB_SKIP: ([" ","\f","\n","\r","\t"])+ >
| < RANK_PROPERTIES: "rank-properties" >
| < RERANK_COUNT: "rerank-count" >
| < NUM_THREADS_PER_SEARCH: "num-threads-per-search" >
| < MIN_HITS_PER_THREAD: "min-hits-per-thread" >
| < NUM_SEARCH_PARTITIONS: "num-search-partitions" >
| < TERMWISE_LIMIT: "termwise-limit" >
| < POST_FILTER_THRESHOLD: "post-filter-threshold" >
| < APPROXIMATE_THRESHOLD: "approximate-threshold" >
| < TARGET_HITS_MAX_ADJUSTMENT_FACTOR: "target-hits-max-adjustment-factor" >
| < KEEP_RANK_COUNT: "keep-rank-count" >
| < RANK_SCORE_DROP_LIMIT: "rank-score-drop-limit" >
| < CONSTANTS: "constants" >
| < FILE: "file" >
| < URI: "uri" >
| < IDENTIFIER:           ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
| < IDENTIFIER_WITH_DASH: ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_","-"])* >
| < DOUBLEQUOTEDSTRING: "\"" ( ~["\""] )* "\"" >
| < SINGLEQUOTEDSTRING: "'" ( ~["'"] )* "'" >
| < CONTEXT: ["a"-"z","A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])* >
| < DOUBLE: ("-")? (["0"-"9"])+ "." (["0"-"9"])+ >
| < INTEGER: ("-")? (["0"-"9"])+ >
| < LONG: ("-")? (["0"-"9"])+"L" >
| < STRING: (["a"-"z","A"-"Z","_","0"-"9","."])+ >
| < FILE_PATH: ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_","-", "/", "."])+ >
| < HTTP: ["h","H"] ["t","T"] ["t","T"] ["p","P"] (["s","S"])? >
| < URI_PATH: <HTTP> <COLON> ("//")? (["a"-"z","A"-"Z","0"-"9","_","-", "/", ".",":"])+ >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < VARIABLE: "$" <IDENTIFIER> >
| < ONNX_INPUT_SL: "input" (" ")* (<IDENTIFIER>|<DOUBLEQUOTEDSTRING>) (" ")* ":" (" ")* (~["\n"])* ("\n")? >
| < ONNX_OUTPUT_SL: "output" (" ")* (<IDENTIFIER>|<DOUBLEQUOTEDSTRING>) (" ")* ":" (" ")* (~["\n"])* ("\n")? >
;


// Declare a special skip token for comments.
UNPARSED :
  <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* >
;


// --------------------------------------------------------------------------------
//
// Production rules.
//
// --------------------------------------------------------------------------------

/**
 * The rule consumes any schema and returns the corresponding object. This is the only production that should
 * ever consume leading newlines.
 *
 * @return the schema object
 * TODO: implement rootDocument
 */
ParsedSchema Root :
{
    ParsedSchema schema;
}
    (<NL>)* (schema = rootSchema)
    { return schema; }
;



/**
 * This rule consumes a proper schema block. This and rootDocument() are the only rules that should ever consume
 * trailing newline tokens.
 *
 * @return the schema definition object.
 * TODO: implement inheritance
 */
ParsedSchema rootSchema :
{
    String name;
    ParsedSchema schema;
}
    ( ( <SCHEMA> | <SEARCH> ) name = identifierStr {
        schema = new ParsedSchema(name);
      }
      openLbrace (rootSchemaItem(schema)! (<NL>)*)*
      <RBRACE> (<NL>)* <EOF> )
    { return schema; }
;

/**
 * Consumes an element of a schema block. This and rootSearch() are the only rules that should ever consume
 * trailing newline tokens.
 *
 * @param schema the schema object to modify.
 */
rootSchemaItem(ParsedSchema schema) : {}
    ( 
        documentElm(schema)
    //   | rawAsBase64(schema)
    //   | searchStemming(schema)
    //   | importField(schema)
    //   | rankingConstant(schema) // Deprecated: TODO: Vespa > 8: Emit warning
        | rankProfile(schema)
    //   | documentSummary(schema)
        | fieldOutsideDoc(schema)
    //   | indexOutsideDoc(schema)
        | structOutsideDoc(schema)
    //   | annotationOutside(schema)
        | fieldSetElm(schema)
    //   | onnxModelInSchema(schema) // Deprecated: TODO: Vespa > 8: Emit warning
 )
;

/**
 * Consumes a document element. The name defaults to the schema's name, but may be set.
 *
 * @param schema the schema object to add content to.
 */
void documentElm(ParsedSchema schema) :
{
    String name = schema.name();
    ParsedDocument document;
}

    ( <DOCUMENT> (name = identifierStr)? (<NL>)*
    {
        document = new ParsedDocument(name);
    }
      openLbrace (documentElmBody(document) (<NL>)*)* <RBRACE> )
    {
        schema.addDocument(document);
    }
;

/**
 * Consumes a document body block
 *
 * @param document the document type to modify.
 */
void documentElmBody(ParsedDocument document) : {}
    (
        structInsideDoc(document)
        | fieldInsideDoc(document)
    )
;

/**
 * Consumes a field block from within a document element.
 *
 * @param document the document type to modify
 */
void fieldInsideDoc(ParsedDocument document) :
{
    ParsedField field;
}
    field = fieldElm() {
        document.addField(field);
    }
;

/**
 * Consumes a field block from outside a document element.
 *
 * @param schema the schema to modify
 */
void fieldOutsideDoc(ParsedSchema schema) :
{
    ParsedField field;
}

    field = fieldElm() { schema.addField(field); }
;

/**
 * Consumes a field block
 * TODO: Reserved names
 */
ParsedField fieldElm() :
{
    String name;
    ParsedField field;
    ParsedType type;
}

    <FIELD> name = identifierStr <TYPE> type = dataType()
    {
        // if (name != null && Schema.isReservedName(name.toLowerCase())) {
        //     throw new IllegalArgumentException("Reserved name '" + name + "' can not be used as a field name.");
        // }
        field = new ParsedField(name, type);
    }
    openLbrace() ( fieldBodyElm(field) (<NL>)*)* <RBRACE>
    {
        return field;
    }
;

/** Consumes a fieldset block */
void fieldSetElm(ParsedSchema schema) :
{
  String name;
  ParsedFieldSet fieldSet;
}

  <FIELDSET> name = identifierStr openLbrace() { fieldSet = new ParsedFieldSet(name); }
    ((fieldsElm(fieldSet) | queryCommandElm(fieldSet)) (<NL>)*)+
  <RBRACE>
  {
     schema.addFieldSet(fieldSet);
  }
;

void fieldsElm(ParsedFieldSet fieldSet) :
{
    String name;
}
    (
        <FIELDS><COLON> name = identifierStr { fieldSet.addField(name); }
        ( <COMMA> name = identifierStr { fieldSet.addField(name); })*
    )
;

void queryCommandElm(ParsedFieldSet fieldSet) :
{
    String queryCommand;
}
    (
        <QUERY_COMMAND><COLON> (queryCommand = identifierWithDashStr | queryCommand = quotedString) { fieldSet.addQueryCommand(queryCommand); }
    )
;

/**
 * This rule consumes a struct block from within a document element.
 * @param document the document object to add content to
 */
void structInsideDoc(ParsedDocument document) :
{
    ParsedStruct struct;
}

    struct = structDefinitionElm() { document.addStruct(struct); }
;

/**
 * This rule consumes a struct block from within a schema element.
 * @param schema the schema object to add content to
 */
void structOutsideDoc(ParsedSchema schema) :
{
    ParsedStruct struct;
}

    struct = structDefinitionElm() { schema.addStruct(struct); }
;

/**
 * This rule consumes a struct declaration block
 */
ParsedStruct structDefinitionElm() :
{
    String name;
//    String inherited;
    ParsedStruct struct;
}

    ( <STRUCT> name = identifierStr (<NL>)* { struct = new ParsedStruct(name); }
//    [ inheritsStruct(struct) (<NL>)* ]
    openLbrace() (structFieldDefinition(struct) (<NL>)*)* <RBRACE> )
    {
        return struct;
    }
;

/**
 * This rule consumes a data type block from within a field element.
 *
 * @return the consumed data type
 */
ParsedType dataType() :
{
    String typeName = null;
    boolean isArrayOldStyle = false;
    ParsedType mapType = null;
    ParsedType arrayType = null;
    ParsedType wsetType = null;
    TensorType tensorType;
    ParsedType referenceType;
}
    (     SCAN(<ARRAY> <LESSTHAN>)               => ( <ARRAY> <LESSTHAN> arrayType = dataType() <GREATERTHAN> { return ParsedType.arrayOf(arrayType); } )
        | SCAN(<WEIGHTEDSET> <LESSTHAN>)         => ( <WEIGHTEDSET> <LESSTHAN> wsetType = dataType() <GREATERTHAN> { return ParsedType.wsetOf(wsetType); } )
        | SCAN(<MAP> <LESSTHAN>)                 => ( mapType = mapDataType() { return mapType; } )
        | SCAN(<ANNOTATIONREFERENCE> <LESSTHAN>) => ( mapType = annotationRefDataType() { return mapType; } )
        | SCAN(<TENSOR_TYPE>)                    => ( tensorType = tensorTypeElm("Field type") { return ParsedType.tensorType(tensorType); } )
        | SCAN(<REFERENCE>)                      => ( <REFERENCE> <LESSTHAN> referenceType = referenceType() <GREATERTHAN> { return ParsedType.documentRef(referenceType); } )
        | ( typeName = identifierStr ["[]" { isArrayOldStyle = true; }] )
    )
    {
        ParsedType type = ParsedType.fromName(typeName);
        if (isArrayOldStyle) {
            //deployLogger.logApplicationPackage(Level.WARNING, "Data type syntax '" + typeName + "[]' is deprecated, use 'array<" + typeName + ">' instead.");
            type = ParsedType.arrayOf(type);
        }
        return type;
    }
;

ParsedType referenceType() :
{
    String documentName;
}

    ( documentName = identifierStr )
    {
        return ParsedType.documentType(documentName);
    }
;

ParsedType annotationRefDataType() :
{
    ParsedType dataType;
    String targetName;
}

    ( <ANNOTATIONREFERENCE> <LESSTHAN> targetName = identifierStr <GREATERTHAN> )
    {
        return ParsedType.annotationRef(targetName);
    }
;

ParsedType mapDataType() :
{
    ParsedType keyType;
    ParsedType valType;
}
  ( <MAP> <LESSTHAN> keyType = dataType() <COMMA> valType = dataType() <GREATERTHAN> )
  {
    return ParsedType.mapType(keyType, valType);
  }
;

/**
 * This rule consumes a field block of a struct body.
 *
 * @param struct The struct to modify.
 */
void structFieldDefinition(ParsedStruct struct) :
{
    String name;
    ParsedType type;
    ParsedField field;
    int fieldId;
}

    <FIELD> name = identifierStr <TYPE> type = dataType() {
//        if (name != null && Schema.isReservedName(name.toLowerCase())) {
        if (name != null && false) {
            throw new IllegalArgumentException("Reserved name '" + name + "' can not be used as a field name.");
        }
        field = new ParsedField(name, type);
    }
    // openLbrace (id(field) (<NL>)*)? (matchSettings(field.matchSettings()) (<NL>)*)* <RBRACE>
    {
        struct.addField(field);
    }
;

/**
 * This rule consumes a single element of a field body block.
 *
 * @param field    the field being built
 */
void fieldBodyElm(ParsedField field) : { }

     ( aliasElm(field) |
       attributeElm(field) |
    //   bolding(field) |
    //   dictionary(field) |
    //   fieldStemming(field) |
       idElm(field) |
    //   summaryInField(field) |
    //   indexInsideField(field) |
    //   indexing(field) |
       matchSettingsElm(field.matchSettings()) |
    //   normalizing(field) |
    //   queryCommand(field) |
       rankElm(field) |
    //   rankType(field) |
    //   fieldSorting(field) |
    //   structField(field) |
    //   summaryTo(field) |
    //   weight(field) |
    //   weightedset(field.getType()) )
      weightElm(field)
    )
;

/**
 * This rule consumes a weight statement of a field element.
 *
 * @param field The field to modify.
 */
void weightElm(ParsedField field) :
{
    int num;
}

    <WEIGHT> <COLON> num = integerElm { field.setWeight(num); }
;

/**
 * This rule consumes an attribute statement of a field element.
 *
 * @param field The field to modify.
 */
void attributeElm(ParsedField field) :
{
    String name = field.name();
}

    <ATTRIBUTE> [name = identifierStr]
    {
        // TODO: Remove support for attribute with different name than field name in Vespa 9
        // if ( ! name.equals(field.name()))
        //         deployLogger.logApplicationPackage(Level.WARNING, "Creating an attribute for field '" + field.name() +
        //         "' with a different name '" + name + "' than the field name" +
        //         " is deprecated, and support will be removed in Vespa 9. Define a field with the wanted name outside the document instead.");
        ParsedAttribute attr = field.attributeFor(name);
    }
         ( (<COLON> attributeSetting(attr))
           | (openLbrace() (attributeSetting(attr) (<NL>)*)* <RBRACE>) )
;

/* pick up sorting in field block */
void attributeSorting(ParsedAttribute attribute) : { }

    sortingElm(attribute.sortInfo())
;

/* pick up sorting in field block */
void sortingElm(ParsedSorting sort) : { }

    <SORTING>
        //  ( (<COLON> sortingSetting(sort))
        //    | (openLbrace() (sortingSetting(sort) (<NL>)*)* <RBRACE>) )
;

/**
 * This rule consumes a single attribute setting statement of an attribute element.
 *
 * @param attribute The attribute to change.
 */
void attributeSetting(ParsedAttribute attribute) :
{
    String str;
}

    (
        <FAST_RANK>             { attribute.setFastRank(true); }
      | <FAST_SEARCH>           { attribute.setFastSearch(true); }
      | <FAST_ACCESS>           { attribute.setFastAccess(true); }
      | <MUTABLE>               { attribute.setMutable(true); }
      | <PAGED>                 { attribute.setPaged(true); }
      | <ENABLE_BIT_VECTORS>      //{ deployLogger.logApplicationPackage(Level.WARNING, "'enable-bit-vectors' is deprecated and void -> remove it. Will be removed in vespa-9"); }
      | <ENABLE_ONLY_BIT_VECTOR>  { attribute.setEnableOnlyBitVector(true); }
      | attributeSorting(attribute)
      | <ALIAS> {
            String alias;
            String aliasedName=attribute.name();
        } [aliasedName = identifierStr] <COLON> alias = identifierWithDashStr {
          attribute.addAlias(aliasedName, alias);
      }
      | <DISTANCE_METRIC> <COLON> str = identifierWithDashStr { attribute.setDistanceMetric(str); }
    )
;

/**
 * Consumes a rank statement of a field element.
 *
 * @param field The field to modify.
 */
void rankElm(ParsedField field) : { }

    <RANK> ( (<COLON> rankSettingElm(field))
             | (openLbrace() (rankSettingElm(field) (<NL>)*)* <RBRACE>) )
;

/**
 * Consumes a single rank setting of a rank statement.
 *
 * @param field The field to modify.
 */
void rankSettingElm(ParsedField field) : { }

    ( <LITERAL>   { field.setLiteral(true); }
      | <NORMAL>  { field.setNormal(true); }
      | <FILTER>  { field.setFilter(true); } )
;


/**
 * Consumes an id statement of a field body block.
 *
 * @param field    The field to modify.
 */
void idElm(ParsedField field) :
{
    int fieldId;
}

    <ID> <COLON> fieldId = integerElm
    {
        field.setId(fieldId);
    }
;

void aliasElm(ParsedField field) :
{
    String aliasedName = field.name();
    String alias;
}

    <ALIAS> [aliasedName = identifierStr] <COLON> alias = identifierWithDashStr
    {
       field.addAlias(aliasedName, alias);
    }
;

void matchSettingsElm(ParsedMatchSettings matchInfo) : { }

    <MATCH> ( (<COLON> matchType(matchInfo))
            //   | (openLbrace() (matchItem(matchInfo) (<NL>)*)* <RBRACE>) )
    )
;

void matchType(ParsedMatchSettings matchInfo) : { }

    (   <MTOKEN>    { matchInfo.setType(MatchType.TEXT); } // Deprecated synonym to TEXT
      | <TEXT>      { matchInfo.setType(MatchType.TEXT); }
      | <WORD>      { matchInfo.setType(MatchType.WORD); }
      | <EXACT>     { matchInfo.setType(MatchType.EXACT); }
      | <GRAM>      { matchInfo.setType(MatchType.GRAM); }
      | <CASED>     { matchInfo.setCase(Case.CASED); }
      | <UNCASED>   { matchInfo.setCase(Case.UNCASED); }
      | <PREFIX>    { matchInfo.setAlgorithm(MatchAlgorithm.PREFIX); }
      | <SUBSTRING> { matchInfo.setAlgorithm(MatchAlgorithm.SUBSTRING); }
      | <SUFFIX>    { matchInfo.setAlgorithm(MatchAlgorithm.SUFFIX); } )
;

/**
 * Consumes a rank-profile block of a schema element.
 *
 * @param schema the schema object to add content to
 */
void rankProfile(ParsedSchema schema) :
{
    String name;
    ParsedRankProfile profile;
}

    ( <MODEL> | <RANK_PROFILE> ) name = identifierWithDashStr
    { profile = new ParsedRankProfile(name); }
    [inheritsRankProfile(profile)]
    openLbrace() (rankProfileItem(schema, profile) (<NL>)*)* <RBRACE>
    {
        schema.addRankProfile(profile);
    }
;

/**
 * This rule consumes a single statement for a rank-profile block.
 *
 * @param profile The rank profile to modify.
 */
void rankProfileItem(ParsedSchema schema, ParsedRankProfile profile) : { }

    (
        firstPhase(profile)
    //   fieldRankType(profile)
    //   | fieldWeight(profile)
    //   | fieldRankFilter(profile)
    //   | firstPhase(profile)
    //   | matchPhase(profile)
    //   | diversity(profile)
    //   | function(profile)
    //   | mutate(profile)
    //   | ignoreRankFeatures(profile)
    //   | numThreadsPerSearch(profile)
    //   | minHitsPerThread(profile)
    //   | numSearchPartitions(profile)
    //   | termwiseLimit(profile)
    //   | postFilterThreshold(profile)
    //   | approximateThreshold(profile)
    //   | targetHitsMaxAdjustmentFactor(profile)
    //   | rankFeatures(profile)
    //   | rankProperties(profile)
    //   | secondPhase(profile)
    //   | globalPhase(profile)
    //   | inputs(profile)
    //   | constants(schema, profile)
    //   | matchFeatures(profile)
    //   | summaryFeatures(profile)
    //   | onnxModelInProfile(profile)
    //   | strict(profile)
    //   | significance(profile)
    )
;

/**
 * Consumes an inherits statement of a rank-profile.
 *
 * @param profile the profile to modify
 */
void inheritsRankProfile(ParsedRankProfile profile) :
{
    String name;
}

    <INHERITS> name = identifierWithDashStr { profile.inherit(name); }
    ( <COMMA>  name = identifierWithDashStr { profile.inherit(name); } )*
;

/**
 * Consumes the first-phase block of a rank profile.
 *
 * @param profile The rank profile to modify.
 */
void firstPhase(ParsedRankProfile profile) :
{
    String exp;
}

    <FIRST_PHASE> openLbrace() (firstPhaseItem(profile) (<NL>)*)* <RBRACE>
;

void firstPhaseItem(ParsedRankProfile profile) :
{
    String expression;
    int keepRankCount;
    double dropLimit;
}

    ( expression = expression()                               { profile.setFirstPhaseRanking(expression); }
    | (<KEEP_RANK_COUNT> <COLON> keepRankCount = integerElm())     { profile.setKeepRankCount(keepRankCount); }
    | (<RANK_SCORE_DROP_LIMIT> <COLON> dropLimit = floatValue()) { profile.setRankScoreDropLimit(dropLimit); }
    )
;

TensorType tensorTypeElm(String errorMessage) :
{
    String tensorTypeString;
}

    <TENSOR_TYPE> { tensorTypeString = lastConsumedToken.toString(); }
    {
        TensorType tensorType;
        try {
            tensorType = TensorType.fromSpec(tensorTypeString);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(errorMessage + ": Illegal tensor type spec: " + e.getMessage());
        }
        return tensorType;
    }
;

/**
 * This rule consumes an expression token and returns its image.
 *
 * @return The consumed token image.
 */
String expression() :
{
    String exp;
}

    ( <EXPRESSION_SL> { exp = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf(":") + 1); } |
      <EXPRESSION_ML> { exp = lastConsumedToken.toString().substring(lastConsumedToken.toString().indexOf("{") + 1,
                                                                     lastConsumedToken.toString().lastIndexOf("}")); } )
    { return exp.trim(); }
;

String identifierWithDashStr :
{
    String identifier;
}

    ( identifier = identifierStr { return identifier; } )
    |
    ( <IDENTIFIER_WITH_DASH>
    | <APPROXIMATE_THRESHOLD>
    | <CREATE_IF_NONEXISTENT>
    | <CUTOFF_FACTOR>
    | <CUTOFF_STRATEGY>
    | <DENSE_POSTING_LIST_THRESHOLD>
    | <DISTANCE_METRIC>
    | <DOCUMENT_SUMMARY>
    | <ENABLE_BIT_VECTORS>
    | <ENABLE_BM25>
    | <ENABLE_ONLY_BIT_VECTOR>
    | <EVALUATION_POINT>
    | <EXACT_TERMINATOR>
    | <EXECUTION_MODE>
    | <FAST_ACCESS>
    | <FAST_RANK>
    | <FAST_SEARCH>
    | <FIRST_PHASE>
    | <FROM_DISK>
    | <GLOBAL_PHASE>
    | <GPU_DEVICE>
    | <GRAM_SIZE>
    | <IGNORE_DEFAULT_RANK_FEATURES>
    | <INTEROP_THREADS>
    | <INTRAOP_THREADS>
    | <KEEP_RANK_COUNT>
    | <LOWER_BOUND>
    | <MATCHED_ELEMENTS_ONLY>
    | <MATCH_PHASE>
    | <MAX_FILTER_COVERAGE>
    | <MAX_HITS>
    | <MAX_LENGTH>
    | <MAX_LINKS_PER_NODE>
    | <MIN_GROUPS>
    | <MIN_HITS_PER_THREAD>
    | <MULTI_THREADED_INDEXING>
    | <NEIGHBORS_TO_EXPLORE_AT_INSERT>
    | <NUM_SEARCH_PARTITIONS>
    | <NUM_THREADS_PER_SEARCH>
    | <OMIT_SUMMARY_FEATURES>
    | <ON_DEMAND>
    | <ON_FIRST_PHASE>
    | <ON_MATCH>
    | <ONNX_MODEL>
    | <ON_SECOND_PHASE>
    | <ON_SUMMARY>
    | <POST_FILTER_THRESHOLD>
    | <PRE_POST_FILTER_TIPPING_POINT>
    | <QUERY_COMMAND>
    | <RANK_PROFILE>
    | <RANK_PROPERTIES>
    | <RANK_SCORE_DROP_LIMIT>
    | <RANK_TYPE>
    | <RAW_AS_BASE64_IN_SUMMARY>
    | <REMOVE_IF_ZERO>
    | <RERANK_COUNT>
    | <SECOND_PHASE>
    | <STRUCT_FIELD>
    | <SUMMARY_TO>
    | <TARGET_HITS_MAX_ADJUSTMENT_FACTOR>
    | <TERMWISE_LIMIT>
    | <UPPER_BOUND>
    | <USE_MODEL>
    ) {
        return lastConsumedToken.toString();
    }
;

/**
 * Consumes an identifier. This must be kept in sync with all word tokens that should be parseable as
 * identifiers.
 *
 * @return the identifier string
 */
String identifierStr :
    ( <ALIAS>
      | <ALWAYS>
      | <ANNOTATION>
      | <ANNOTATIONREFERENCE>
      | <ARITY>
      | <ARRAY>
      | <AS>
      | <ASCENDING>
      | <ATTRIBUTE>
      | <BOLDING>
      | <BTREE>
      | <CASED>
      | <CONSTANT>
      | <CONSTANTS>
      | <CONTEXT>
      | <DESCENDING>
      | <DICTIONARY>
      | <DIRECT>
      | <DIVERSITY>
      | <DOCUMENT>
      | <DOUBLE_KEYWORD>
      | <FLOAT_KEYWORD>
      | <LONG_KEYWORD>
      | <STRING_KEYWORD>
      | <DYNAMIC>
      | <EXACT>
      | <FALSE>
      | <FIELD>
      | <FIELDS>
      | <FIELDSET>
      | <FILE>
      | <FILTER>
      | <FULL>
      | <FUNCTION>
      | <GRAM>
      | <HASH>
      | <HNSW>
      | <ID>
      | <IDENTICAL>
      | <IDENTIFIER>
      | <IMPORT>
      | <INDEX>
      | <INDEXING>
      | <INHERITS>
      | <INLINE>
      | <INPUTS>
      | <INTEGER>
      | <LITERAL>
      | <LOCALE>
      | <LONG>
      | <LOOSE>
      | <LOWERCASE>
      | <MACRO>
      | <MAP>
      | <MATCH>
      | <MODEL>
      | <MTOKEN>
      | <MUTABLE>
      | <MUTATE>
      | <NEVER>
      | <NONE>
      | <NORMAL>
      | <NORMALIZING>
      | <OFF>
      | <ON>
      | <OPERATION>
      | <ORDER>
      | <PAGED>
      | <PARALLEL>
      | <PREFIX>
      | <PRIMARY>
      | <PROPERTIES>
      | <QUATERNARY>
      | <QUERY>
      | <RANK>
      | <RAW>
      | <REFERENCE>
      | <SCHEMA>
      | <SEARCH>
      | <SECONDARY>
      | <SEQUENTIAL>
      | <SORTING>
      | <SOURCE>
      | <SSCONTEXTUAL>
      | <SSOVERRIDE>
      | <SSTITLE>
      | <SSURL>
      | <STATIC>
      | <STEMMING>
      | <STRENGTH>
      | <STRICT>
      | <SIGNIFICANCE>
      | <STRING>
      | <STRUCT>
      | <SUBSTRING>
      | <SUFFIX>
      | <SUMMARY>
      | <SYMMETRIC>
      | <TERTIARY>
      | <TEXT>
      | <TO>
      | <TOKENS>
      | <TRUE>
      | <TYPE>
      | <UCA>
      | <UNCASED>
      | <URI>
      | <VARIABLE>
      | <WEIGHT>
      | <WEIGHTEDSET>
      | <WORD>
    ) {
        return lastConsumedToken.toString();
    }
;

/**
 * Consumes a quoted string token and returns the token image minus the quotes. This does not perform
 * unescaping of the content, it simply removes the first and last character of the image. However, the token itself can
 * contain anything but a double quote.
 *
 * @return the unquoted token image
 */
String quotedString() : { }

    ( <DOUBLEQUOTEDSTRING> | <SINGLEQUOTEDSTRING> )
    { return lastConsumedToken.toString().substring(1, lastConsumedToken.toString().length() - 1); }
;

/** A boolean value. */
Boolean bool() :

    ( ( <ON>  | <TRUE> )  { return true; } |
      ( <OFF> | <FALSE> ) { return false; } )
;

/** Consumes an integer token and returns its numeric value. */
int integerElm() : { }

    <INTEGER> { return Integer.parseInt(lastConsumedToken.toString()); }
;

/** Consumes a long or integer token and returns its numeric value. */
long longValue() : { }

    ( <INTEGER> { return Long.parseLong(lastConsumedToken.toString()); } |
      <LONG>    { return Long.parseLong(lastConsumedToken.toString().substring(0, lastConsumedToken.toString().length() - 1)); }
    )
;

/** Consumes a floating-point token and returns its numeric value. */
double floatValue() : { }

    <DOUBLE> { return Double.valueOf(lastConsumedToken.toString()); }
;

Number number() :
{
    Number num;
}

    ( num = floatValue | num = longValue ) { return num; }
;

openLbrace :
    (<NL>)* <LBRACE> (<NL>)*
;