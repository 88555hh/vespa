# Schema Language Server
This directory contains both a backend and some frontends for providing language support when writing schema files.

It uses the LSP protocol for communicating with different clients. LSP is a way to standardize the way language support is provided by defining a set of messages and types that the server and client will use to communicate over JSON RPC.

https://microsoft.github.io/language-server-protocol/

This means that the bulk of the functionality lies inside /language-server. The clients are merely small bootstrapping wrappers for creating an extension/plugin and launching the language-server.

## Basic Principles
The server is launched as an executable by the client that wants to use it. It will then run as a separate process, and they will communicate using standard input/output.
Upon initialization, the server and client will exchange 'capabilities'. The server defines the subset of the LSP specification it supports, and the client does the same.

The main bookkeeping work typically happens through textDocument/didOpen and textDocument/didChange requests. 
The client gives the server the entire contents of the current text document. The server then does the following:

- Parse the entire file using a parser generated with CongoCC parser generator. The parsing step constructs a syntax tree, CST, of the entire schema file.
- Traverse the CST to identify syntax errors, semantic errors, symbol definitions, symbol references and some type information.
- Resolve stuff like inheritance, type information, indexing language and ranking expressions
- Try to resolve all symbol references using the current set of known definitions. 
- The above steps may generate a bunch of warnings or errors, known as 'diagnostics'. In the end the server publishes the diagnostics and they are shown in the UI of the client.

During the above process, symbols and their relationships are registered in a global index. A symbol is anything with a user-defined identifier, for instance a field, a document, a struct etc.
The remaining LSP requests simply use the index and CST generated in the parsing step.

## Parser
We needed a fault tolerant parser for parsing the schema language. A fault tolerant parser can continue parsing even if there exists some syntax errors 
in the document - this is crucial for providing good language support, as most of the time a document is not finished.

The original Schema parser, written in JavaCC, is not fault tolerant. To avoid duplicating the entire language definition we ideally wanted a fault tolerant version
of the exact same parser that is used for deploying Vespa applications. That is of course impossible, 
however CongoCC is the continuation of a project called "JavaCC 21", which in turn is a continuation of JavaCC. CongoCC supports fault tolerant parsing and
generates an AST/CST out of the box.

The syntax in CongoCC is very similar to JavaCC, the most notable differences being SCAN instead of LOOKAHEAD, and slightly different syntax for defining a rule.

We therefore ported the JavaCC parsers for the schema language, indexing language and ranking expressions to CongoCC and added some small modifications.
The modifications we made are mainly to catch some exceptions early and add some bookkeeping information to some nodes in the AST.

## Model
Many errors that can occur when creating a Vespa application are not caught in the parsing phase but much later. In order to make the language server as
simple, fault tolerant and flexible as possible, we sacrificed some correctness. This means that we don't go through all the steps you usually do when deploying
an applications, but try to catch as much as possible by inspecting the CST. 

This means that the language server will not catch all possible mistakes you can do when writing a schema, but a correct schema should never show any errors.

We have split the "parsing" process into three steps, "parse", "identify" and "resolve". This involves a few traversals of the CST (maybe more than strictly necessary).
The errors generated by "identify" and "resolve" involves some very specific inspections of the syntax tree. 

This means that we don't model the 'Vespa application', but rather assign symbol types to different nodes in the syntax tree and use information about where they are 
to determine semantic correctness of the schema. It allows all constructs to be traced to their exact location in a text document, and symbols can reference other symbols across files.

## LSP
A brief description of the types of requests we support:

- initialize: Capabilities are exchanged. If we want to support a new type of LSP request we must register it as a capability in this phase.
- textDocument/didOpen: First time the client opens a specific document (or reopens after a textDocument/didClose). If it is the first document the server has seen during
the execution, the server will also look for a /schemas directory among the files ancestors. If found, the server scans the contents of /schemas recursively and processes all .sd- and .profile-files it can find.
- textDocument/didChange: Reparses the content of a file. Also traverses document inheritance and document reference graphs to reparse descendants of the current document.
- textDocument/completion: Uses the most recently updated file content and supplied cursor position to generate a relevant completion list.
- textDocument/codeAction: Using the supplied position and known diagnostics, get some actions the user can select from. This is mostly used for supplying "Quick fix" for certain error messages.
- textDocument/references: Find a list of symbols referencing the symbol at the current position. As references are already resolved during the parsing traversal, this is quite simple.
- textDocument/documentSymbol: Gives a hierarchical list of symbols in the current document. Since symbols are registered during parsing traversal, this is also quite simple.
- textDocument/rename: If the cursor is at a symbol, rename it to a new identifier. It will find all references to the symbol and create TextEdit objects describing how to change them. May involve renaming symbols across files and renaming files.
- textDocument/semanticTokens/full: Gives a list of all tokens in the current document, translated to some standard types. This enables syntax highlighting. As constructs in the schema language
are not common in other languages (for instance "rank-profile"), we have made a somewhat arbitrary conversion to the standard types that makes the colors look good.
- textDocument/definition: If the cursor is a symbol, give the location where it was defined. For instance a field reference in a fieldset will refer to the original place where field was defined.
- workspace/didDeleteFiles: Unregister files and symbols.
- workspace/didRenameFiles: Effectively delete -> add.
